.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PARALLEL_TUTORIAL 7"
.TH PARALLEL_TUTORIAL 7 "2020-04-22" "20200322" "parallel"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "GNU Parallel Tutorial"
.IX Header "GNU Parallel Tutorial"
This tutorial shows off much of \s-1GNU\s0 \fBparallel\fR's functionality. The
tutorial is meant to learn the options in and syntax of \s-1GNU\s0
\&\fBparallel\fR.  The tutorial is \fBnot\fR to show realistic examples from the
real world.
.SS "Reader's guide"
.IX Subsection "Reader's guide"
If you prefer reading a book buy \fB\s-1GNU\s0 Parallel 2018\fR at
http://www.lulu.com/shop/ole\-tange/gnu\-parallel\-2018/paperback/product\-23558902.html
or download it at: https://doi.org/10.5281/zenodo.1146014
.PP
Otherwise start by watching the intro videos for a quick introduction:
http://www.youtube.com/playlist?list=PL284C9FF2488BC6D1
.PP
Then browse through the \fB\s-1EXAMPLE\s0\fRs after the list of \fB\s-1OPTIONS\s0\fR in
\&\fBman parallel\fR (Use \fBLESS=+/EXAMPLE: man parallel\fR). That will give
you an idea of what \s-1GNU\s0 \fBparallel\fR is capable of.
.PP
If you want to dive even deeper: spend a couple of hours walking
through the tutorial (\fBman parallel_tutorial\fR). Your command line
will love you for it.
.PP
Finally you may want to look at the rest of the manual (\fBman
parallel\fR) if you have special needs not already covered.
.PP
If you want to know the design decisions behind \s-1GNU\s0 \fBparallel\fR, try:
\&\fBman parallel_design\fR. This is also a good intro if you intend to
change \s-1GNU\s0 \fBparallel\fR.
.SH "Prerequisites"
.IX Header "Prerequisites"
To run this tutorial you must have the following:
.IP "parallel >= version 20160822" 9
.IX Item "parallel >= version 20160822"
Install the newest version using your package manager (recommended for
security reasons), the way described in \s-1README,\s0 or with this command:
.Sp
.Vb 10
\&  $ (wget \-O \- pi.dk/3 || lynx \-source pi.dk/3 || curl pi.dk/3/ || \e
\&     fetch \-o \- http://pi.dk/3 ) > install.sh
\&  $ sha1sum install.sh
\&  12345678 3374ec53 bacb199b 245af2dd a86df6c9
\&  $ md5sum install.sh
\&  029a9ac0 6e8b5bc6 052eac57 b2c3c9ca
\&  $ sha512sum install.sh
\&  40f53af6 9e20dae5 713ba06c f517006d 9897747b ed8a4694 b1acba1b 1464beb4
\&  60055629 3f2356f3 3e9c4e3c 76e3f3af a9db4b32 bd33322b 975696fc e6b23cfb
\&  $ bash install.sh
.Ve
.Sp
This will also install the newest version of the tutorial which you
can see by running this:
.Sp
.Vb 1
\&  man parallel_tutorial
.Ve
.Sp
Most of the tutorial will work on older versions, too.
.IP "abc-file:" 9
.IX Item "abc-file:"
The file can be generated by this command:
.Sp
.Vb 1
\&  parallel \-k echo ::: A B C > abc\-file
.Ve
.IP "def-file:" 9
.IX Item "def-file:"
The file can be generated by this command:
.Sp
.Vb 1
\&  parallel \-k echo ::: D E F > def\-file
.Ve
.IP "abc0\-file:" 9
.IX Item "abc0-file:"
The file can be generated by this command:
.Sp
.Vb 1
\&  perl \-e \*(Aqprintf "A\e0B\e0C\e0"\*(Aq > abc0\-file
.Ve
.IP "abc_\-file:" 9
.IX Item "abc_-file:"
The file can be generated by this command:
.Sp
.Vb 1
\&  perl \-e \*(Aqprintf "A_B_C_"\*(Aq > abc_\-file
.Ve
.IP "tsv\-file.tsv" 9
.IX Item "tsv-file.tsv"
The file can be generated by this command:
.Sp
.Vb 1
\&  perl \-e \*(Aqprintf "f1\etf2\enA\etB\enC\etD\en"\*(Aq > tsv\-file.tsv
.Ve
.IP "num8" 9
.IX Item "num8"
The file can be generated by this command:
.Sp
.Vb 1
\&  perl \-e \*(Aqfor(1..8){print "$_\en"}\*(Aq > num8
.Ve
.IP "num128" 9
.IX Item "num128"
The file can be generated by this command:
.Sp
.Vb 1
\&  perl \-e \*(Aqfor(1..128){print "$_\en"}\*(Aq > num128
.Ve
.IP "num30000" 9
.IX Item "num30000"
The file can be generated by this command:
.Sp
.Vb 1
\&  perl \-e \*(Aqfor(1..30000){print "$_\en"}\*(Aq > num30000
.Ve
.IP "num1000000" 9
.IX Item "num1000000"
The file can be generated by this command:
.Sp
.Vb 1
\&  perl \-e \*(Aqfor(1..1000000){print "$_\en"}\*(Aq > num1000000
.Ve
.IP "num_%header" 9
.IX Item "num_%header"
The file can be generated by this command:
.Sp
.Vb 2
\&  (echo %head1; echo %head2; \e
\&   perl \-e \*(Aqfor(1..10){print "$_\en"}\*(Aq) > num_%header
.Ve
.IP "fixedlen" 9
.IX Item "fixedlen"
The file can be generated by this command:
.Sp
.Vb 1
\&  perl \-e \*(Aqprint "HHHHAAABBBCCC"\*(Aq > fixedlen
.Ve
.ie n .IP "For remote running: ssh login on 2 servers with no password in $SERVER1 and $SERVER2 must work." 9
.el .IP "For remote running: ssh login on 2 servers with no password in \f(CW$SERVER1\fR and \f(CW$SERVER2\fR must work." 9
.IX Item "For remote running: ssh login on 2 servers with no password in $SERVER1 and $SERVER2 must work."
.Vb 2
\&  SERVER1=server.example.com
\&  SERVER2=server2.example.net
.Ve
.Sp
So you must be able to do this without entering a password:
.Sp
.Vb 2
\&  ssh $SERVER1 echo works
\&  ssh $SERVER2 echo works
.Ve
.Sp
It can be setup by running 'ssh\-keygen \-t dsa; ssh-copy-id \f(CW$SERVER1\fR'
and using an empty passphrase, or you can use \fBssh-agent\fR.
.SH "Input sources"
.IX Header "Input sources"
\&\s-1GNU\s0 \fBparallel\fR reads input from input sources. These can be files, the
command line, and stdin (standard input or a pipe).
.SS "A single input source"
.IX Subsection "A single input source"
Input can be read from the command line:
.PP
.Vb 1
\&  parallel echo ::: A B C
.Ve
.PP
Output (the order may be different because the jobs are run in
parallel):
.PP
.Vb 3
\&  A
\&  B
\&  C
.Ve
.PP
The input source can be a file:
.PP
.Vb 1
\&  parallel \-a abc\-file echo
.Ve
.PP
Output: Same as above.
.PP
\&\s-1STDIN\s0 (standard input) can be the input source:
.PP
.Vb 1
\&  cat abc\-file | parallel echo
.Ve
.PP
Output: Same as above.
.SS "Multiple input sources"
.IX Subsection "Multiple input sources"
\&\s-1GNU\s0 \fBparallel\fR can take multiple input sources given on the command
line. \s-1GNU\s0 \fBparallel\fR then generates all combinations of the input
sources:
.PP
.Vb 1
\&  parallel echo ::: A B C ::: D E F
.Ve
.PP
Output (the order may be different):
.PP
.Vb 9
\&  A D
\&  A E
\&  A F
\&  B D
\&  B E
\&  B F
\&  C D
\&  C E
\&  C F
.Ve
.PP
The input sources can be files:
.PP
.Vb 1
\&  parallel \-a abc\-file \-a def\-file echo
.Ve
.PP
Output: Same as above.
.PP
\&\s-1STDIN\s0 (standard input) can be one of the input sources using \fB\-\fR:
.PP
.Vb 1
\&  cat abc\-file | parallel \-a \- \-a def\-file echo
.Ve
.PP
Output: Same as above.
.PP
Instead of \fB\-a\fR files can be given after \fB::::\fR:
.PP
.Vb 1
\&  cat abc\-file | parallel echo :::: \- def\-file
.Ve
.PP
Output: Same as above.
.PP
::: and :::: can be mixed:
.PP
.Vb 1
\&  parallel echo ::: A B C :::: def\-file
.Ve
.PP
Output: Same as above.
.PP
\fILinking arguments from input sources\fR
.IX Subsection "Linking arguments from input sources"
.PP
With \fB\-\-link\fR you can link the input sources and get one argument
from each input source:
.PP
.Vb 1
\&  parallel \-\-link echo ::: A B C ::: D E F
.Ve
.PP
Output (the order may be different):
.PP
.Vb 3
\&  A D
\&  B E
\&  C F
.Ve
.PP
If one of the input sources is too short, its values will wrap:
.PP
.Vb 1
\&  parallel \-\-link echo ::: A B C D E ::: F G
.Ve
.PP
Output (the order may be different):
.PP
.Vb 5
\&  A F
\&  B G
\&  C F
\&  D G
\&  E F
.Ve
.PP
For more flexible linking you can use \fB:::+\fR and \fB::::+\fR. They work
like \fB:::\fR and \fB::::\fR except they link the previous input source to
this input source.
.PP
This will link \s-1ABC\s0 to \s-1GHI:\s0
.PP
.Vb 1
\&  parallel echo :::: abc\-file :::+ G H I :::: def\-file
.Ve
.PP
Output (the order may be different):
.PP
.Vb 9
\&  A G D
\&  A G E
\&  A G F
\&  B H D
\&  B H E
\&  B H F
\&  C I D
\&  C I E
\&  C I F
.Ve
.PP
This will link \s-1GHI\s0 to \s-1DEF:\s0
.PP
.Vb 1
\&  parallel echo :::: abc\-file ::: G H I ::::+ def\-file
.Ve
.PP
Output (the order may be different):
.PP
.Vb 9
\&  A G D
\&  A H E
\&  A I F
\&  B G D
\&  B H E
\&  B I F
\&  C G D
\&  C H E
\&  C I F
.Ve
.PP
If one of the input sources is too short when using \fB:::+\fR or
\&\fB::::+\fR, the rest will be ignored:
.PP
.Vb 1
\&  parallel echo ::: A B C D E :::+ F G
.Ve
.PP
Output (the order may be different):
.PP
.Vb 2
\&  A F
\&  B G
.Ve
.SS "Changing the argument separator."
.IX Subsection "Changing the argument separator."
\&\s-1GNU\s0 \fBparallel\fR can use other separators than \fB:::\fR or \fB::::\fR. This is
typically useful if \fB:::\fR or \fB::::\fR is used in the command to run:
.PP
.Vb 1
\&  parallel \-\-arg\-sep ,, echo ,, A B C :::: def\-file
.Ve
.PP
Output (the order may be different):
.PP
.Vb 9
\&  A D
\&  A E
\&  A F
\&  B D
\&  B E
\&  B F
\&  C D
\&  C E
\&  C F
.Ve
.PP
Changing the argument file separator:
.PP
.Vb 1
\&  parallel \-\-arg\-file\-sep // echo ::: A B C // def\-file
.Ve
.PP
Output: Same as above.
.SS "Changing the argument delimiter"
.IX Subsection "Changing the argument delimiter"
\&\s-1GNU\s0 \fBparallel\fR will normally treat a full line as a single argument: It
uses \fB\en\fR as argument delimiter. This can be changed with \fB\-d\fR:
.PP
.Vb 1
\&  parallel \-d _ echo :::: abc_\-file
.Ve
.PP
Output (the order may be different):
.PP
.Vb 3
\&  A
\&  B
\&  C
.Ve
.PP
\&\s-1NUL\s0 can be given as \fB\e0\fR:
.PP
.Vb 1
\&  parallel \-d \*(Aq\e0\*(Aq echo :::: abc0\-file
.Ve
.PP
Output: Same as above.
.PP
A shorthand for \fB\-d '\e0'\fR is \fB\-0\fR (this will often be used to read files
from \fBfind ... \-print0\fR):
.PP
.Vb 1
\&  parallel \-0 echo :::: abc0\-file
.Ve
.PP
Output: Same as above.
.SS "End-of-file value for input source"
.IX Subsection "End-of-file value for input source"
\&\s-1GNU\s0 \fBparallel\fR can stop reading when it encounters a certain value:
.PP
.Vb 1
\&  parallel \-E stop echo ::: A B stop C D
.Ve
.PP
Output:
.PP
.Vb 2
\&  A
\&  B
.Ve
.SS "Skipping empty lines"
.IX Subsection "Skipping empty lines"
Using \fB\-\-no\-run\-if\-empty\fR \s-1GNU\s0 \fBparallel\fR will skip empty lines.
.PP
.Vb 1
\&  (echo 1; echo; echo 2) | parallel \-\-no\-run\-if\-empty echo
.Ve
.PP
Output:
.PP
.Vb 2
\&  1
\&  2
.Ve
.SH "Building the command line"
.IX Header "Building the command line"
.SS "No command means arguments are commands"
.IX Subsection "No command means arguments are commands"
If no command is given after parallel the arguments themselves are
treated as commands:
.PP
.Vb 1
\&  parallel ::: ls \*(Aqecho foo\*(Aq pwd
.Ve
.PP
Output (the order may be different):
.PP
.Vb 3
\&  [list of files in current dir]
\&  foo
\&  [/path/to/current/working/dir]
.Ve
.PP
The command can be a script, a binary or a Bash function if the function is
exported using \fBexport \-f\fR:
.PP
.Vb 6
\&  # Only works in Bash
\&  my_func() {
\&    echo in my_func $1
\&  }
\&  export \-f my_func
\&  parallel my_func ::: 1 2 3
.Ve
.PP
Output (the order may be different):
.PP
.Vb 3
\&  in my_func 1
\&  in my_func 2
\&  in my_func 3
.Ve
.SS "Replacement strings"
.IX Subsection "Replacement strings"
\fIThe 7 predefined replacement strings\fR
.IX Subsection "The 7 predefined replacement strings"
.PP
\&\s-1GNU\s0 \fBparallel\fR has several replacement strings. If no replacement
strings are used the default is to append \fB{}\fR:
.PP
.Vb 1
\&  parallel echo ::: A/B.C
.Ve
.PP
Output:
.PP
.Vb 1
\&  A/B.C
.Ve
.PP
The default replacement string is \fB{}\fR:
.PP
.Vb 1
\&  parallel echo {} ::: A/B.C
.Ve
.PP
Output:
.PP
.Vb 1
\&  A/B.C
.Ve
.PP
The replacement string \fB{.}\fR removes the extension:
.PP
.Vb 1
\&  parallel echo {.} ::: A/B.C
.Ve
.PP
Output:
.PP
.Vb 1
\&  A/B
.Ve
.PP
The replacement string \fB{/}\fR removes the path:
.PP
.Vb 1
\&  parallel echo {/} ::: A/B.C
.Ve
.PP
Output:
.PP
.Vb 1
\&  B.C
.Ve
.PP
The replacement string \fB{//}\fR keeps only the path:
.PP
.Vb 1
\&  parallel echo {//} ::: A/B.C
.Ve
.PP
Output:
.PP
.Vb 1
\&  A
.Ve
.PP
The replacement string \fB{/.}\fR removes the path and the extension:
.PP
.Vb 1
\&  parallel echo {/.} ::: A/B.C
.Ve
.PP
Output:
.PP
.Vb 1
\&  B
.Ve
.PP
The replacement string \fB{#}\fR gives the job number:
.PP
.Vb 1
\&  parallel echo {#} ::: A B C
.Ve
.PP
Output (the order may be different):
.PP
.Vb 3
\&  1
\&  2
\&  3
.Ve
.PP
The replacement string \fB{%}\fR gives the job slot number (between 1 and
number of jobs to run in parallel):
.PP
.Vb 1
\&  parallel \-j 2 echo {%} ::: A B C
.Ve
.PP
Output (the order may be different and 1 and 2 may be swapped):
.PP
.Vb 3
\&  1
\&  2
\&  1
.Ve
.PP
\fIChanging the replacement strings\fR
.IX Subsection "Changing the replacement strings"
.PP
The replacement string \fB{}\fR can be changed with \fB\-I\fR:
.PP
.Vb 1
\&  parallel \-I ,, echo ,, ::: A/B.C
.Ve
.PP
Output:
.PP
.Vb 1
\&  A/B.C
.Ve
.PP
The replacement string \fB{.}\fR can be changed with \fB\-\-extensionreplace\fR:
.PP
.Vb 1
\&  parallel \-\-extensionreplace ,, echo ,, ::: A/B.C
.Ve
.PP
Output:
.PP
.Vb 1
\&  A/B
.Ve
.PP
The replacement string \fB{/}\fR can be replaced with \fB\-\-basenamereplace\fR:
.PP
.Vb 1
\&  parallel \-\-basenamereplace ,, echo ,, ::: A/B.C
.Ve
.PP
Output:
.PP
.Vb 1
\&  B.C
.Ve
.PP
The replacement string \fB{//}\fR can be changed with \fB\-\-dirnamereplace\fR:
.PP
.Vb 1
\&  parallel \-\-dirnamereplace ,, echo ,, ::: A/B.C
.Ve
.PP
Output:
.PP
.Vb 1
\&  A
.Ve
.PP
The replacement string \fB{/.}\fR can be changed with \fB\-\-basenameextensionreplace\fR:
.PP
.Vb 1
\&  parallel \-\-basenameextensionreplace ,, echo ,, ::: A/B.C
.Ve
.PP
Output:
.PP
.Vb 1
\&  B
.Ve
.PP
The replacement string \fB{#}\fR can be changed with \fB\-\-seqreplace\fR:
.PP
.Vb 1
\&  parallel \-\-seqreplace ,, echo ,, ::: A B C
.Ve
.PP
Output (the order may be different):
.PP
.Vb 3
\&  1
\&  2
\&  3
.Ve
.PP
The replacement string \fB{%}\fR can be changed with \fB\-\-slotreplace\fR:
.PP
.Vb 1
\&  parallel \-j2 \-\-slotreplace ,, echo ,, ::: A B C
.Ve
.PP
Output (the order may be different and 1 and 2 may be swapped):
.PP
.Vb 3
\&  1
\&  2
\&  1
.Ve
.PP
\fIPerl expression replacement string\fR
.IX Subsection "Perl expression replacement string"
.PP
When predefined replacement strings are not flexible enough a perl
expression can be used instead. One example is to remove two
extensions: foo.tar.gz becomes foo
.PP
.Vb 1
\&  parallel echo \*(Aq{= s:\e.[^.]+$::;s:\e.[^.]+$::; =}\*(Aq ::: foo.tar.gz
.Ve
.PP
Output:
.PP
.Vb 1
\&  foo
.Ve
.PP
In \fB{= =}\fR you can access all of \s-1GNU\s0 \fBparallel\fR's internal functions
and variables. A few are worth mentioning.
.PP
\&\fB\f(BItotal_jobs()\fB\fR returns the total number of jobs:
.PP
.Vb 1
\&  parallel echo Job {#} of {= \*(Aq$_=total_jobs()\*(Aq =} ::: {1..5}
.Ve
.PP
Output:
.PP
.Vb 5
\&  Job 1 of 5
\&  Job 2 of 5
\&  Job 3 of 5
\&  Job 4 of 5
\&  Job 5 of 5
.Ve
.PP
\&\fBQ(...)\fR shell quotes the string:
.PP
.Vb 1
\&  parallel echo {} shell quoted is {= \*(Aq$_=Q($_)\*(Aq =} ::: \*(Aq*/!#$\*(Aq
.Ve
.PP
Output:
.PP
.Vb 1
\&  */!#$ shell quoted is \e*/\e!\e#\e$
.Ve
.PP
\&\fB\f(BIskip()\fB\fR skips the job:
.PP
.Vb 1
\&  parallel echo {= \*(Aqif($_==3) { skip() }\*(Aq =} ::: {1..5}
.Ve
.PP
Output:
.PP
.Vb 4
\&  1
\&  2
\&  4
\&  5
.Ve
.PP
\&\fB\f(CB@arg\fB\fR contains the input source variables:
.PP
.Vb 2
\&  parallel echo {= \*(Aqif($arg[1]==$arg[2]) { skip() }\*(Aq =} \e
\&    ::: {1..3} ::: {1..3}
.Ve
.PP
Output:
.PP
.Vb 6
\&  1 2
\&  1 3
\&  2 1
\&  2 3
\&  3 1
\&  3 2
.Ve
.PP
If the strings \fB{=\fR and \fB=}\fR cause problems they can be replaced with \fB\-\-parens\fR:
.PP
.Vb 2
\&  parallel \-\-parens ,,,, echo \*(Aq,, s:\e.[^.]+$::;s:\e.[^.]+$::; ,,\*(Aq \e
\&    ::: foo.tar.gz
.Ve
.PP
Output:
.PP
.Vb 1
\&  foo
.Ve
.PP
To define a shorthand replacement string use \fB\-\-rpl\fR:
.PP
.Vb 2
\&  parallel \-\-rpl \*(Aq.. s:\e.[^.]+$::;s:\e.[^.]+$::;\*(Aq echo \*(Aq..\*(Aq \e
\&    ::: foo.tar.gz
.Ve
.PP
Output: Same as above.
.PP
If the shorthand starts with \fB{\fR it can be used as a positional
replacement string, too:
.PP
.Vb 2
\&  parallel \-\-rpl \*(Aq{..} s:\e.[^.]+$::;s:\e.[^.]+$::;\*(Aq echo \*(Aq{..}\*(Aq
\&    ::: foo.tar.gz
.Ve
.PP
Output: Same as above.
.PP
If the shorthand contains matching parenthesis the replacement string
becomes a dynamic replacement string and the string in the parenthesis
can be accessed as $$1. If there are multiple matching parenthesis,
the matched strings can be accessed using $$2, $$3 and so on.
.PP
You can think of this as giving arguments to the replacement
string. Here we give the argument \fB.tar.gz\fR to the replacement string
\&\fB{%\f(BIstring\fB}\fR which removes \fIstring\fR:
.PP
.Vb 1
\&  parallel \-\-rpl \*(Aq{%(.+?)} s/$$1$//;\*(Aq echo {%.tar.gz}.zip ::: foo.tar.gz
.Ve
.PP
Output:
.PP
.Vb 1
\&  foo.zip
.Ve
.PP
Here we give the two arguments \fBtar.gz\fR and \fBzip\fR to the replacement
string \fB{/\f(BIstring1\fB/\f(BIstring2\fB}\fR which replaces \fIstring1\fR with
\&\fIstring2\fR:
.PP
.Vb 2
\&  parallel \-\-rpl \*(Aq{/(.+?)/(.*?)} s/$$1/$$2/;\*(Aq echo {/tar.gz/zip} \e
\&    ::: foo.tar.gz
.Ve
.PP
Output:
.PP
.Vb 1
\&  foo.zip
.Ve
.PP
\&\s-1GNU\s0 \fBparallel\fR's 7 replacement strings are implemented as this:
.PP
.Vb 8
\&  \-\-rpl \*(Aq{} \*(Aq
\&  \-\-rpl \*(Aq{#} $_=$job\->seq()\*(Aq
\&  \-\-rpl \*(Aq{%} $_=$job\->slot()\*(Aq
\&  \-\-rpl \*(Aq{/} s:.*/::\*(Aq
\&  \-\-rpl \*(Aq{//} $Global::use{"File::Basename"} ||=
\&           eval "use File::Basename; 1;"; $_ = dirname($_);\*(Aq
\&  \-\-rpl \*(Aq{/.} s:.*/::; s:\e.[^/.]+$::;\*(Aq
\&  \-\-rpl \*(Aq{.} s:\e.[^/.]+$::\*(Aq
.Ve
.PP
\fIPositional replacement strings\fR
.IX Subsection "Positional replacement strings"
.PP
With multiple input sources the argument from the individual input
sources can be accessed with \fB{\fRnumber\fB}\fR:
.PP
.Vb 1
\&  parallel echo {1} and {2} ::: A B ::: C D
.Ve
.PP
Output (the order may be different):
.PP
.Vb 4
\&  A and C
\&  A and D
\&  B and C
\&  B and D
.Ve
.PP
The positional replacement strings can also be modified using \fB/\fR, \fB//\fR, \fB/.\fR, and  \fB.\fR:
.PP
.Vb 1
\&  parallel echo /={1/} //={1//} /.={1/.} .={1.} ::: A/B.C D/E.F
.Ve
.PP
Output (the order may be different):
.PP
.Vb 2
\&  /=B.C //=A /.=B .=A/B
\&  /=E.F //=D /.=E .=D/E
.Ve
.PP
If a position is negative, it will refer to the input source counted
from behind:
.PP
.Vb 2
\&  parallel echo 1={1} 2={2} 3={3} \-1={\-1} \-2={\-2} \-3={\-3} \e
\&    ::: A B ::: C D ::: E F
.Ve
.PP
Output (the order may be different):
.PP
.Vb 8
\&  1=A 2=C 3=E \-1=E \-2=C \-3=A
\&  1=A 2=C 3=F \-1=F \-2=C \-3=A
\&  1=A 2=D 3=E \-1=E \-2=D \-3=A
\&  1=A 2=D 3=F \-1=F \-2=D \-3=A
\&  1=B 2=C 3=E \-1=E \-2=C \-3=B
\&  1=B 2=C 3=F \-1=F \-2=C \-3=B
\&  1=B 2=D 3=E \-1=E \-2=D \-3=B
\&  1=B 2=D 3=F \-1=F \-2=D \-3=B
.Ve
.PP
\fIPositional perl expression replacement string\fR
.IX Subsection "Positional perl expression replacement string"
.PP
To use a perl expression as a positional replacement string simply
prepend the perl expression with number and space:
.PP
.Vb 2
\&  parallel echo \*(Aq{=2 s:\e.[^.]+$::;s:\e.[^.]+$::; =} {1}\*(Aq \e
\&    ::: bar ::: foo.tar.gz
.Ve
.PP
Output:
.PP
.Vb 1
\&  foo bar
.Ve
.PP
If a shorthand defined using \fB\-\-rpl\fR starts with \fB{\fR it can be used as
a positional replacement string, too:
.PP
.Vb 2
\&  parallel \-\-rpl \*(Aq{..} s:\e.[^.]+$::;s:\e.[^.]+$::;\*(Aq echo \*(Aq{2..} {1}\*(Aq \e
\&    ::: bar ::: foo.tar.gz
.Ve
.PP
Output: Same as above.
.PP
\fIInput from columns\fR
.IX Subsection "Input from columns"
.PP
The columns in a file can be bound to positional replacement strings
using \fB\-\-colsep\fR. Here the columns are separated by \s-1TAB\s0 (\et):
.PP
.Vb 1
\&  parallel \-\-colsep \*(Aq\et\*(Aq echo 1={1} 2={2} :::: tsv\-file.tsv
.Ve
.PP
Output (the order may be different):
.PP
.Vb 3
\&  1=f1 2=f2
\&  1=A 2=B
\&  1=C 2=D
.Ve
.PP
\fIHeader defined replacement strings\fR
.IX Subsection "Header defined replacement strings"
.PP
With \fB\-\-header\fR \s-1GNU\s0 \fBparallel\fR will use the first value of the input
source as the name of the replacement string. Only the non-modified
version \fB{}\fR is supported:
.PP
.Vb 1
\&  parallel \-\-header : echo f1={f1} f2={f2} ::: f1 A B ::: f2 C D
.Ve
.PP
Output (the order may be different):
.PP
.Vb 4
\&  f1=A f2=C
\&  f1=A f2=D
\&  f1=B f2=C
\&  f1=B f2=D
.Ve
.PP
It is useful with \fB\-\-colsep\fR for processing files with \s-1TAB\s0 separated values:
.PP
.Vb 2
\&  parallel \-\-header : \-\-colsep \*(Aq\et\*(Aq echo f1={f1} f2={f2} \e
\&    :::: tsv\-file.tsv
.Ve
.PP
Output (the order may be different):
.PP
.Vb 2
\&  f1=A f2=B
\&  f1=C f2=D
.Ve
.PP
\fIMore pre-defined replacement strings with \-\-plus\fR
.IX Subsection "More pre-defined replacement strings with --plus"
.PP
\&\fB\-\-plus\fR adds the replacement strings \fB{+/} {+.} {+..} {+...} {..}  {...}
{/..} {/...} {##}\fR. The idea being that \fB{+foo}\fR matches the opposite of \fB{foo}\fR
and \fB{}\fR = \fB{+/}\fR/\fB{/}\fR = \fB{.}\fR.\fB{+.}\fR = \fB{+/}\fR/\fB{/.}\fR.\fB{+.}\fR = \fB{..}\fR.\fB{+..}\fR =
\&\fB{+/}\fR/\fB{/..}\fR.\fB{+..}\fR = \fB{...}\fR.\fB{+...}\fR = \fB{+/}\fR/\fB{/...}\fR.\fB{+...}\fR.
.PP
.Vb 8
\&  parallel \-\-plus echo {} ::: dir/sub/file.ex1.ex2.ex3
\&  parallel \-\-plus echo {+/}/{/} ::: dir/sub/file.ex1.ex2.ex3
\&  parallel \-\-plus echo {.}.{+.} ::: dir/sub/file.ex1.ex2.ex3
\&  parallel \-\-plus echo {+/}/{/.}.{+.} ::: dir/sub/file.ex1.ex2.ex3
\&  parallel \-\-plus echo {..}.{+..} ::: dir/sub/file.ex1.ex2.ex3
\&  parallel \-\-plus echo {+/}/{/..}.{+..} ::: dir/sub/file.ex1.ex2.ex3
\&  parallel \-\-plus echo {...}.{+...} ::: dir/sub/file.ex1.ex2.ex3
\&  parallel \-\-plus echo {+/}/{/...}.{+...} ::: dir/sub/file.ex1.ex2.ex3
.Ve
.PP
Output:
.PP
.Vb 1
\&  dir/sub/file.ex1.ex2.ex3
.Ve
.PP
\&\fB{##}\fR is simply the number of jobs:
.PP
.Vb 1
\&  parallel \-\-plus echo Job {#} of {##} ::: {1..5}
.Ve
.PP
Output:
.PP
.Vb 5
\&  Job 1 of 5
\&  Job 2 of 5
\&  Job 3 of 5
\&  Job 4 of 5
\&  Job 5 of 5
.Ve
.PP
\fIDynamic replacement strings with \-\-plus\fR
.IX Subsection "Dynamic replacement strings with --plus"
.PP
\&\fB\-\-plus\fR also defines these dynamic replacement strings:
.IP "\fB{:\-\f(BIstring\fB}\fR" 19
.IX Item "{:-string}"
Default value is \fIstring\fR if the argument is empty.
.IP "\fB{:\f(BInumber\fB}\fR" 19
.IX Item "{:number}"
Substring from \fInumber\fR till end of string.
.IP "\fB{:\f(BInumber1\fB:\f(BInumber2\fB}\fR" 19
.IX Item "{:number1:number2}"
Substring from \fInumber1\fR to \fInumber2\fR.
.IP "\fB{#\f(BIstring\fB}\fR" 19
.IX Item "{#string}"
If the argument starts with \fIstring\fR, remove it.
.IP "\fB{%\f(BIstring\fB}\fR" 19
.IX Item "{%string}"
If the argument ends with \fIstring\fR, remove it.
.IP "\fB{/\f(BIstring1\fB/\f(BIstring2\fB}\fR" 19
.IX Item "{/string1/string2}"
Replace \fIstring1\fR with \fIstring2\fR.
.IP "\fB{^\f(BIstring\fB}\fR" 19
.IX Item "{^string}"
If the argument starts with \fIstring\fR, upper case it. \fIstring\fR must
be a single letter.
.IP "\fB{^^\f(BIstring\fB}\fR" 19
.IX Item "{^^string}"
If the argument contains \fIstring\fR, upper case it. \fIstring\fR must be a
single letter.
.IP "\fB{,\f(BIstring\fB}\fR" 19
.IX Item "{,string}"
If the argument starts with \fIstring\fR, lower case it. \fIstring\fR must
be a single letter.
.IP "\fB{,,\f(BIstring\fB}\fR" 19
.IX Item "{,,string}"
If the argument contains \fIstring\fR, lower case it. \fIstring\fR must be a
single letter.
.PP
They are inspired from \fBBash\fR:
.PP
.Vb 3
\&  unset myvar
\&  echo ${myvar:\-myval}
\&  parallel \-\-plus echo {:\-myval} ::: "$myvar"
\&
\&  myvar=abcAaAdef
\&  echo ${myvar:2}
\&  parallel \-\-plus echo {:2} ::: "$myvar"
\&
\&  echo ${myvar:2:3}
\&  parallel \-\-plus echo {:2:3} ::: "$myvar"
\&
\&  echo ${myvar#bc}
\&  parallel \-\-plus echo {#bc} ::: "$myvar"
\&  echo ${myvar#abc}
\&  parallel \-\-plus echo {#abc} ::: "$myvar"
\&
\&  echo ${myvar%de}
\&  parallel \-\-plus echo {%de} ::: "$myvar"
\&  echo ${myvar%def}
\&  parallel \-\-plus echo {%def} ::: "$myvar"
\&
\&  echo ${myvar/def/ghi}
\&  parallel \-\-plus echo {/def/ghi} ::: "$myvar"
\&
\&  echo ${myvar^a}
\&  parallel \-\-plus echo {^a} ::: "$myvar"
\&  echo ${myvar^^a}
\&  parallel \-\-plus echo {^^a} ::: "$myvar"
\&
\&  myvar=AbcAaAdef
\&  echo ${myvar,A}
\&  parallel \-\-plus echo \*(Aq{,A}\*(Aq ::: "$myvar"
\&  echo ${myvar,,A}
\&  parallel \-\-plus echo \*(Aq{,,A}\*(Aq ::: "$myvar"
.Ve
.PP
Output:
.PP
.Vb 10
\&  myval
\&  myval
\&  cAaAdef
\&  cAaAdef
\&  cAa
\&  cAa
\&  abcAaAdef
\&  abcAaAdef
\&  AaAdef
\&  AaAdef
\&  abcAaAdef
\&  abcAaAdef
\&  abcAaA
\&  abcAaA
\&  abcAaAghi
\&  abcAaAghi
\&  AbcAaAdef
\&  AbcAaAdef
\&  AbcAAAdef
\&  AbcAAAdef
\&  abcAaAdef
\&  abcAaAdef
\&  abcaaadef
\&  abcaaadef
.Ve
.SS "More than one argument"
.IX Subsection "More than one argument"
With \fB\-\-xargs\fR \s-1GNU\s0 \fBparallel\fR will fit as many arguments as possible on a
single line:
.PP
.Vb 1
\&  cat num30000 | parallel \-\-xargs echo | wc \-l
.Ve
.PP
Output (if you run this under Bash on GNU/Linux):
.PP
.Vb 1
\&  2
.Ve
.PP
The 30000 arguments fitted on 2 lines.
.PP
The maximal length of a single line can be set with \fB\-s\fR. With a maximal
line length of 10000 chars 17 commands will be run:
.PP
.Vb 1
\&  cat num30000 | parallel \-\-xargs \-s 10000 echo | wc \-l
.Ve
.PP
Output:
.PP
.Vb 1
\&  17
.Ve
.PP
For better parallelism \s-1GNU\s0 \fBparallel\fR can distribute the arguments
between all the parallel jobs when end of file is met.
.PP
Below \s-1GNU\s0 \fBparallel\fR reads the last argument when generating the second
job. When \s-1GNU\s0 \fBparallel\fR reads the last argument, it spreads all the
arguments for the second job over 4 jobs instead, as 4 parallel jobs
are requested.
.PP
The first job will be the same as the \fB\-\-xargs\fR example above, but the
second job will be split into 4 evenly sized jobs, resulting in a
total of 5 jobs:
.PP
.Vb 1
\&  cat num30000 | parallel \-\-jobs 4 \-m echo | wc \-l
.Ve
.PP
Output (if you run this under Bash on GNU/Linux):
.PP
.Vb 1
\&  5
.Ve
.PP
This is even more visible when running 4 jobs with 10 arguments. The
10 arguments are being spread over 4 jobs:
.PP
.Vb 1
\&  parallel \-\-jobs 4 \-m echo ::: 1 2 3 4 5 6 7 8 9 10
.Ve
.PP
Output:
.PP
.Vb 4
\&  1 2 3
\&  4 5 6
\&  7 8 9
\&  10
.Ve
.PP
A replacement string can be part of a word. \fB\-m\fR will not repeat the context:
.PP
.Vb 1
\&  parallel \-\-jobs 4 \-m echo pre\-{}\-post ::: A B C D E F G
.Ve
.PP
Output (the order may be different):
.PP
.Vb 4
\&  pre\-A B\-post
\&  pre\-C D\-post
\&  pre\-E F\-post
\&  pre\-G\-post
.Ve
.PP
To repeat the context use \fB\-X\fR which otherwise works like \fB\-m\fR:
.PP
.Vb 1
\&  parallel \-\-jobs 4 \-X echo pre\-{}\-post ::: A B C D E F G
.Ve
.PP
Output (the order may be different):
.PP
.Vb 4
\&  pre\-A\-post pre\-B\-post
\&  pre\-C\-post pre\-D\-post
\&  pre\-E\-post pre\-F\-post
\&  pre\-G\-post
.Ve
.PP
To limit the number of arguments use \fB\-N\fR:
.PP
.Vb 1
\&  parallel \-N3 echo ::: A B C D E F G H
.Ve
.PP
Output (the order may be different):
.PP
.Vb 3
\&  A B C
\&  D E F
\&  G H
.Ve
.PP
\&\fB\-N\fR also sets the positional replacement strings:
.PP
.Vb 1
\&  parallel \-N3 echo 1={1} 2={2} 3={3} ::: A B C D E F G H
.Ve
.PP
Output (the order may be different):
.PP
.Vb 3
\&  1=A 2=B 3=C
\&  1=D 2=E 3=F
\&  1=G 2=H 3=
.Ve
.PP
\&\fB\-N0\fR reads 1 argument but inserts none:
.PP
.Vb 1
\&  parallel \-N0 echo foo ::: 1 2 3
.Ve
.PP
Output:
.PP
.Vb 3
\&  foo
\&  foo
\&  foo
.Ve
.SS "Quoting"
.IX Subsection "Quoting"
Command lines that contain special characters may need to be protected from the shell.
.PP
The \fBperl\fR program \fBprint \*(L"@ARGV\en\*(R"\fR basically works like \fBecho\fR.
.PP
.Vb 1
\&  perl \-e \*(Aqprint "@ARGV\en"\*(Aq A
.Ve
.PP
Output:
.PP
.Vb 1
\&  A
.Ve
.PP
To run that in parallel the command needs to be quoted:
.PP
.Vb 1
\&  parallel perl \-e \*(Aqprint "@ARGV\en"\*(Aq ::: This wont work
.Ve
.PP
Output:
.PP
.Vb 1
\&  [Nothing]
.Ve
.PP
To quote the command use \fB\-q\fR:
.PP
.Vb 1
\&  parallel \-q perl \-e \*(Aqprint "@ARGV\en"\*(Aq ::: This works
.Ve
.PP
Output (the order may be different):
.PP
.Vb 2
\&  This
\&  works
.Ve
.PP
Or you can quote the critical part using \fB\e'\fR:
.PP
.Vb 1
\&  parallel perl \-e \e\*(Aq\*(Aqprint "@ARGV\en"\*(Aq\e\*(Aq ::: This works, too
.Ve
.PP
Output (the order may be different):
.PP
.Vb 3
\&  This
\&  works,
\&  too
.Ve
.PP
\&\s-1GNU\s0 \fBparallel\fR can also \e\-quote full lines. Simply run this:
.PP
.Vb 8
\&  parallel \-\-shellquote
\&  Warning: Input is read from the terminal. You either know what you
\&  Warning: are doing (in which case: YOU ARE AWESOME!) or you forgot
\&  Warning: ::: or :::: or to pipe data into parallel. If so
\&  Warning: consider going through the tutorial: man parallel_tutorial
\&  Warning: Press CTRL\-D to exit.
\&  perl \-e \*(Aqprint "@ARGV\en"\*(Aq
\&  [CTRL\-D]
.Ve
.PP
Output:
.PP
.Vb 1
\&  perl\e \-e\e \e\*(Aqprint\e \e"@ARGV\e\en\e"\e\*(Aq
.Ve
.PP
This can then be used as the command:
.PP
.Vb 1
\&  parallel perl\e \-e\e \e\*(Aqprint\e \e"@ARGV\e\en\e"\e\*(Aq ::: This also works
.Ve
.PP
Output (the order may be different):
.PP
.Vb 3
\&  This
\&  also
\&  works
.Ve
.SS "Trimming space"
.IX Subsection "Trimming space"
Space can be trimmed on the arguments using \fB\-\-trim\fR:
.PP
.Vb 1
\&  parallel \-\-trim r echo pre\-{}\-post ::: \*(Aq A \*(Aq
.Ve
.PP
Output:
.PP
.Vb 1
\&  pre\- A\-post
.Ve
.PP
To trim on the left side:
.PP
.Vb 1
\&  parallel \-\-trim l echo pre\-{}\-post ::: \*(Aq A \*(Aq
.Ve
.PP
Output:
.PP
.Vb 1
\&  pre\-A \-post
.Ve
.PP
To trim on the both sides:
.PP
.Vb 1
\&  parallel \-\-trim lr echo pre\-{}\-post ::: \*(Aq A \*(Aq
.Ve
.PP
Output:
.PP
.Vb 1
\&  pre\-A\-post
.Ve
.SS "Respecting the shell"
.IX Subsection "Respecting the shell"
This tutorial uses Bash as the shell. \s-1GNU\s0 \fBparallel\fR respects which
shell you are using, so in \fBzsh\fR you can do:
.PP
.Vb 1
\&  parallel echo \e={} ::: zsh bash ls
.Ve
.PP
Output:
.PP
.Vb 3
\&  /usr/bin/zsh
\&  /bin/bash
\&  /bin/ls
.Ve
.PP
In \fBcsh\fR you can do:
.PP
.Vb 1
\&  parallel \*(Aqset a="{}"; if( { test \-d "$a" } ) echo "$a is a dir"\*(Aq ::: *
.Ve
.PP
Output:
.PP
.Vb 1
\&  [somedir] is a dir
.Ve
.PP
This also becomes useful if you use \s-1GNU\s0 \fBparallel\fR in a shell script:
\&\s-1GNU\s0 \fBparallel\fR will use the same shell as the shell script.
.SH "Controlling the output"
.IX Header "Controlling the output"
The output can prefixed with the argument:
.PP
.Vb 1
\&  parallel \-\-tag echo foo\-{} ::: A B C
.Ve
.PP
Output (the order may be different):
.PP
.Vb 3
\&  A       foo\-A
\&  B       foo\-B
\&  C       foo\-C
.Ve
.PP
To prefix it with another string use \fB\-\-tagstring\fR:
.PP
.Vb 1
\&  parallel \-\-tagstring {}\-bar echo foo\-{} ::: A B C
.Ve
.PP
Output (the order may be different):
.PP
.Vb 3
\&  A\-bar   foo\-A
\&  B\-bar   foo\-B
\&  C\-bar   foo\-C
.Ve
.PP
To see what commands will be run without running them use \fB\-\-dryrun\fR:
.PP
.Vb 1
\&  parallel \-\-dryrun echo {} ::: A B C
.Ve
.PP
Output (the order may be different):
.PP
.Vb 3
\&  echo A
\&  echo B
\&  echo C
.Ve
.PP
To print the command before running them use \fB\-\-verbose\fR:
.PP
.Vb 1
\&  parallel \-\-verbose echo {} ::: A B C
.Ve
.PP
Output (the order may be different):
.PP
.Vb 6
\&  echo A
\&  echo B
\&  A
\&  echo C
\&  B
\&  C
.Ve
.PP
\&\s-1GNU\s0 \fBparallel\fR will postpone the output until the command completes:
.PP
.Vb 2
\&  parallel \-j2 \*(Aqprintf "%s\-start\en%s" {} {};
\&    sleep {};printf "%s\en" \-middle;echo {}\-end\*(Aq ::: 4 2 1
.Ve
.PP
Output:
.PP
.Vb 9
\&  2\-start
\&  2\-middle
\&  2\-end
\&  1\-start
\&  1\-middle
\&  1\-end
\&  4\-start
\&  4\-middle
\&  4\-end
.Ve
.PP
To get the output immediately use \fB\-\-ungroup\fR:
.PP
.Vb 2
\&  parallel \-j2 \-\-ungroup \*(Aqprintf "%s\-start\en%s" {} {};
\&    sleep {};printf "%s\en" \-middle;echo {}\-end\*(Aq ::: 4 2 1
.Ve
.PP
Output:
.PP
.Vb 9
\&  4\-start
\&  42\-start
\&  2\-middle
\&  2\-end
\&  1\-start
\&  1\-middle
\&  1\-end
\&  \-middle
\&  4\-end
.Ve
.PP
\&\fB\-\-ungroup\fR is fast, but can cause half a line from one job to be mixed
with half a line of another job. That has happened in the second line,
where the line '4\-middle' is mixed with '2\-start'.
.PP
To avoid this use \fB\-\-linebuffer\fR:
.PP
.Vb 2
\&  parallel \-j2 \-\-linebuffer \*(Aqprintf "%s\-start\en%s" {} {};
\&    sleep {};printf "%s\en" \-middle;echo {}\-end\*(Aq ::: 4 2 1
.Ve
.PP
Output:
.PP
.Vb 9
\&  4\-start
\&  2\-start
\&  2\-middle
\&  2\-end
\&  1\-start
\&  1\-middle
\&  1\-end
\&  4\-middle
\&  4\-end
.Ve
.PP
To force the output in the same order as the arguments use \fB\-\-keep\-order\fR/\fB\-k\fR:
.PP
.Vb 2
\&  parallel \-j2 \-k \*(Aqprintf "%s\-start\en%s" {} {};
\&    sleep {};printf "%s\en" \-middle;echo {}\-end\*(Aq ::: 4 2 1
.Ve
.PP
Output:
.PP
.Vb 9
\&  4\-start
\&  4\-middle
\&  4\-end
\&  2\-start
\&  2\-middle
\&  2\-end
\&  1\-start
\&  1\-middle
\&  1\-end
.Ve
.SS "Saving output into files"
.IX Subsection "Saving output into files"
\&\s-1GNU\s0 \fBparallel\fR can save the output of each job into files:
.PP
.Vb 1
\&  parallel \-\-files echo ::: A B C
.Ve
.PP
Output will be similar to this:
.PP
.Vb 3
\&  /tmp/pAh6uWuQCg.par
\&  /tmp/opjhZCzAX4.par
\&  /tmp/W0AT_Rph2o.par
.Ve
.PP
By default \s-1GNU\s0 \fBparallel\fR will cache the output in files in \fB/tmp\fR. This
can be changed by setting \fB\f(CB$TMPDIR\fB\fR or \fB\-\-tmpdir\fR:
.PP
.Vb 1
\&  parallel \-\-tmpdir /var/tmp \-\-files echo ::: A B C
.Ve
.PP
Output will be similar to this:
.PP
.Vb 3
\&  /var/tmp/N_vk7phQRc.par
\&  /var/tmp/7zA4Ccf3wZ.par
\&  /var/tmp/LIuKgF_2LP.par
.Ve
.PP
Or:
.PP
.Vb 1
\&  TMPDIR=/var/tmp parallel \-\-files echo ::: A B C
.Ve
.PP
Output: Same as above.
.PP
The output files can be saved in a structured way using \fB\-\-results\fR:
.PP
.Vb 1
\&  parallel \-\-results outdir echo ::: A B C
.Ve
.PP
Output:
.PP
.Vb 3
\&  A
\&  B
\&  C
.Ve
.PP
These files were also generated containing the standard output
(stdout), standard error (stderr), and the sequence number (seq):
.PP
.Vb 9
\&  outdir/1/A/seq
\&  outdir/1/A/stderr
\&  outdir/1/A/stdout
\&  outdir/1/B/seq
\&  outdir/1/B/stderr
\&  outdir/1/B/stdout
\&  outdir/1/C/seq
\&  outdir/1/C/stderr
\&  outdir/1/C/stdout
.Ve
.PP
\&\fB\-\-header :\fR will take the first value as name and use that in the
directory structure. This is useful if you are using multiple input
sources:
.PP
.Vb 1
\&  parallel \-\-header : \-\-results outdir echo ::: f1 A B ::: f2 C D
.Ve
.PP
Generated files:
.PP
.Vb 12
\&  outdir/f1/A/f2/C/seq
\&  outdir/f1/A/f2/C/stderr
\&  outdir/f1/A/f2/C/stdout
\&  outdir/f1/A/f2/D/seq
\&  outdir/f1/A/f2/D/stderr
\&  outdir/f1/A/f2/D/stdout
\&  outdir/f1/B/f2/C/seq
\&  outdir/f1/B/f2/C/stderr
\&  outdir/f1/B/f2/C/stdout
\&  outdir/f1/B/f2/D/seq
\&  outdir/f1/B/f2/D/stderr
\&  outdir/f1/B/f2/D/stdout
.Ve
.PP
The directories are named after the variables and their values.
.SH "Controlling the execution"
.IX Header "Controlling the execution"
.SS "Number of simultaneous jobs"
.IX Subsection "Number of simultaneous jobs"
The number of concurrent jobs is given with \fB\-\-jobs\fR/\fB\-j\fR:
.PP
.Vb 1
\&  /usr/bin/time parallel \-N0 \-j64 sleep 1 :::: num128
.Ve
.PP
With 64 jobs in parallel the 128 \fBsleep\fRs will take 2\-8 seconds to run \-
depending on how fast your machine is.
.PP
By default \fB\-\-jobs\fR is the same as the number of \s-1CPU\s0 cores. So this:
.PP
.Vb 1
\&  /usr/bin/time parallel \-N0 sleep 1 :::: num128
.Ve
.PP
should take twice the time of running 2 jobs per \s-1CPU\s0 core:
.PP
.Vb 1
\&  /usr/bin/time parallel \-N0 \-\-jobs 200% sleep 1 :::: num128
.Ve
.PP
\&\fB\-\-jobs 0\fR will run as many jobs in parallel as possible:
.PP
.Vb 1
\&  /usr/bin/time parallel \-N0 \-\-jobs 0 sleep 1 :::: num128
.Ve
.PP
which should take 1\-7 seconds depending on how fast your machine is.
.PP
\&\fB\-\-jobs\fR can read from a file which is re-read when a job finishes:
.PP
.Vb 5
\&  echo 50% > my_jobs
\&  /usr/bin/time parallel \-N0 \-\-jobs my_jobs sleep 1 :::: num128 &
\&  sleep 1
\&  echo 0 > my_jobs
\&  wait
.Ve
.PP
The first second only 50% of the \s-1CPU\s0 cores will run a job. Then \fB0\fR is
put into \fBmy_jobs\fR and then the rest of the jobs will be started in
parallel.
.PP
Instead of basing the percentage on the number of \s-1CPU\s0 cores
\&\s-1GNU\s0 \fBparallel\fR can base it on the number of CPUs:
.PP
.Vb 1
\&  parallel \-\-use\-cpus\-instead\-of\-cores \-N0 sleep 1 :::: num8
.Ve
.SS "Shuffle job order"
.IX Subsection "Shuffle job order"
If you have many jobs (e.g. by multiple combinations of input
sources), it can be handy to shuffle the jobs, so you get different
values run. Use \fB\-\-shuf\fR for that:
.PP
.Vb 1
\&  parallel \-\-shuf echo ::: 1 2 3 ::: a b c ::: A B C
.Ve
.PP
Output:
.PP
.Vb 1
\&  All combinations but different order for each run.
.Ve
.SS "Interactivity"
.IX Subsection "Interactivity"
\&\s-1GNU\s0 \fBparallel\fR can ask the user if a command should be run using \fB\-\-interactive\fR:
.PP
.Vb 1
\&  parallel \-\-interactive echo ::: 1 2 3
.Ve
.PP
Output:
.PP
.Vb 5
\&  echo 1 ?...y
\&  echo 2 ?...n
\&  1
\&  echo 3 ?...y
\&  3
.Ve
.PP
\&\s-1GNU\s0 \fBparallel\fR can be used to put arguments on the command line for an
interactive command such as \fBemacs\fR to edit one file at a time:
.PP
.Vb 1
\&  parallel \-\-tty emacs ::: 1 2 3
.Ve
.PP
Or give multiple argument in one go to open multiple files:
.PP
.Vb 1
\&  parallel \-X \-\-tty vi ::: 1 2 3
.Ve
.SS "A terminal for every job"
.IX Subsection "A terminal for every job"
Using \fB\-\-tmux\fR \s-1GNU\s0 \fBparallel\fR can start a terminal for every job run:
.PP
.Vb 1
\&  seq 10 20 | parallel \-\-tmux \*(Aqecho start {}; sleep {}; echo done {}\*(Aq
.Ve
.PP
This will tell you to run something similar to:
.PP
.Vb 1
\&  tmux \-S /tmp/tmsrPrO0 attach
.Ve
.PP
Using normal \fBtmux\fR keystrokes (CTRL-b n or CTRL-b p) you can cycle
between windows of the running jobs. When a job is finished it will
pause for 10 seconds before closing the window.
.SS "Timing"
.IX Subsection "Timing"
Some jobs do heavy I/O when they start. To avoid a thundering herd \s-1GNU\s0
\&\fBparallel\fR can delay starting new jobs. \fB\-\-delay\fR \fIX\fR will make
sure there is at least \fIX\fR seconds between each start:
.PP
.Vb 1
\&  parallel \-\-delay 2.5 echo Starting {}\e;date ::: 1 2 3
.Ve
.PP
Output:
.PP
.Vb 6
\&  Starting 1
\&  Thu Aug 15 16:24:33 CEST 2013
\&  Starting 2
\&  Thu Aug 15 16:24:35 CEST 2013
\&  Starting 3
\&  Thu Aug 15 16:24:38 CEST 2013
.Ve
.PP
If jobs taking more than a certain amount of time are known to fail,
they can be stopped with \fB\-\-timeout\fR. The accuracy of \fB\-\-timeout\fR is
2 seconds:
.PP
.Vb 1
\&  parallel \-\-timeout 4.1 sleep {}\e; echo {} ::: 2 4 6 8
.Ve
.PP
Output:
.PP
.Vb 2
\&  2
\&  4
.Ve
.PP
\&\s-1GNU\s0 \fBparallel\fR can compute the median runtime for jobs and kill those
that take more than 200% of the median runtime:
.PP
.Vb 1
\&  parallel \-\-timeout 200% sleep {}\e; echo {} ::: 2.1 2.2 3 7 2.3
.Ve
.PP
Output:
.PP
.Vb 4
\&  2.1
\&  2.2
\&  3
\&  2.3
.Ve
.SS "Progress information"
.IX Subsection "Progress information"
Based on the runtime of completed jobs \s-1GNU\s0 \fBparallel\fR can estimate the
total runtime:
.PP
.Vb 1
\&  parallel \-\-eta sleep ::: 1 3 2 2 1 3 3 2 1
.Ve
.PP
Output:
.PP
.Vb 2
\&  Computers / CPU cores / Max jobs to run
\&  1:local / 2 / 2
\&
\&  Computer:jobs running/jobs completed/%of started jobs/
\&    Average seconds to complete
\&  ETA: 2s 0left 1.11avg  local:0/9/100%/1.1s
.Ve
.PP
\&\s-1GNU\s0 \fBparallel\fR can give progress information with \fB\-\-progress\fR:
.PP
.Vb 1
\&  parallel \-\-progress sleep ::: 1 3 2 2 1 3 3 2 1
.Ve
.PP
Output:
.PP
.Vb 2
\&  Computers / CPU cores / Max jobs to run
\&  1:local / 2 / 2
\&
\&  Computer:jobs running/jobs completed/%of started jobs/
\&    Average seconds to complete
\&  local:0/9/100%/1.1s
.Ve
.PP
A progress bar can be shown with \fB\-\-bar\fR:
.PP
.Vb 1
\&  parallel \-\-bar sleep ::: 1 3 2 2 1 3 3 2 1
.Ve
.PP
And a graphic bar can be shown with \fB\-\-bar\fR and \fBzenity\fR:
.PP
.Vb 2
\&  seq 1000 | parallel \-j10 \-\-bar \*(Aq(echo \-n {};sleep 0.1)\*(Aq \e
\&    2> >(zenity \-\-progress \-\-auto\-kill \-\-auto\-close)
.Ve
.PP
A logfile of the jobs completed so far can be generated with \fB\-\-joblog\fR:
.PP
.Vb 2
\&  parallel \-\-joblog /tmp/log exit  ::: 1 2 3 0
\&  cat /tmp/log
.Ve
.PP
Output:
.PP
.Vb 5
\&  Seq Host Starttime      Runtime Send Receive Exitval Signal Command
\&  1   :    1376577364.974 0.008   0    0       1       0      exit 1
\&  2   :    1376577364.982 0.013   0    0       2       0      exit 2
\&  3   :    1376577364.990 0.013   0    0       3       0      exit 3
\&  4   :    1376577365.003 0.003   0    0       0       0      exit 0
.Ve
.PP
The log contains the job sequence, which host the job was run on, the
start time and run time, how much data was transferred, the exit
value, the signal that killed the job, and finally the command being
run.
.PP
With a joblog \s-1GNU\s0 \fBparallel\fR can be stopped and later pickup where it
left off. It it important that the input of the completed jobs is
unchanged.
.PP
.Vb 4
\&  parallel \-\-joblog /tmp/log exit  ::: 1 2 3 0
\&  cat /tmp/log
\&  parallel \-\-resume \-\-joblog /tmp/log exit  ::: 1 2 3 0 0 0
\&  cat /tmp/log
.Ve
.PP
Output:
.PP
.Vb 5
\&  Seq Host Starttime      Runtime Send Receive Exitval Signal Command
\&  1   :    1376580069.544 0.008   0    0       1       0      exit 1
\&  2   :    1376580069.552 0.009   0    0       2       0      exit 2
\&  3   :    1376580069.560 0.012   0    0       3       0      exit 3
\&  4   :    1376580069.571 0.005   0    0       0       0      exit 0
\&
\&  Seq Host Starttime      Runtime Send Receive Exitval Signal Command
\&  1   :    1376580069.544 0.008   0    0       1       0      exit 1
\&  2   :    1376580069.552 0.009   0    0       2       0      exit 2
\&  3   :    1376580069.560 0.012   0    0       3       0      exit 3
\&  4   :    1376580069.571 0.005   0    0       0       0      exit 0
\&  5   :    1376580070.028 0.009   0    0       0       0      exit 0
\&  6   :    1376580070.038 0.007   0    0       0       0      exit 0
.Ve
.PP
Note how the start time of the last 2 jobs is clearly different from the second run.
.PP
With \fB\-\-resume\-failed\fR \s-1GNU\s0 \fBparallel\fR will re-run the jobs that failed:
.PP
.Vb 2
\&  parallel \-\-resume\-failed \-\-joblog /tmp/log exit  ::: 1 2 3 0 0 0
\&  cat /tmp/log
.Ve
.PP
Output:
.PP
.Vb 10
\&  Seq Host Starttime      Runtime Send Receive Exitval Signal Command
\&  1   :    1376580069.544 0.008   0    0       1       0      exit 1
\&  2   :    1376580069.552 0.009   0    0       2       0      exit 2
\&  3   :    1376580069.560 0.012   0    0       3       0      exit 3
\&  4   :    1376580069.571 0.005   0    0       0       0      exit 0
\&  5   :    1376580070.028 0.009   0    0       0       0      exit 0
\&  6   :    1376580070.038 0.007   0    0       0       0      exit 0
\&  1   :    1376580154.433 0.010   0    0       1       0      exit 1
\&  2   :    1376580154.444 0.022   0    0       2       0      exit 2
\&  3   :    1376580154.466 0.005   0    0       3       0      exit 3
.Ve
.PP
Note how seq 1 2 3 have been repeated because they had exit value
different from 0.
.PP
\&\fB\-\-retry\-failed\fR does almost the same as \fB\-\-resume\-failed\fR. Where
\&\fB\-\-resume\-failed\fR reads the commands from the command line (and
ignores the commands in the joblog), \fB\-\-retry\-failed\fR ignores the
command line and reruns the commands mentioned in the joblog.
.PP
.Vb 2
\&  parallel \-\-retry\-failed \-\-joblog /tmp/log
\&  cat /tmp/log
.Ve
.PP
Output:
.PP
.Vb 10
\&  Seq Host Starttime      Runtime Send Receive Exitval Signal Command
\&  1   :    1376580069.544 0.008   0    0       1       0      exit 1
\&  2   :    1376580069.552 0.009   0    0       2       0      exit 2
\&  3   :    1376580069.560 0.012   0    0       3       0      exit 3
\&  4   :    1376580069.571 0.005   0    0       0       0      exit 0
\&  5   :    1376580070.028 0.009   0    0       0       0      exit 0
\&  6   :    1376580070.038 0.007   0    0       0       0      exit 0
\&  1   :    1376580154.433 0.010   0    0       1       0      exit 1
\&  2   :    1376580154.444 0.022   0    0       2       0      exit 2
\&  3   :    1376580154.466 0.005   0    0       3       0      exit 3
\&  1   :    1376580164.633 0.010   0    0       1       0      exit 1
\&  2   :    1376580164.644 0.022   0    0       2       0      exit 2
\&  3   :    1376580164.666 0.005   0    0       3       0      exit 3
.Ve
.SS "Termination"
.IX Subsection "Termination"
\fIUnconditional termination\fR
.IX Subsection "Unconditional termination"
.PP
By default \s-1GNU\s0 \fBparallel\fR will wait for all jobs to finish before exiting.
.PP
If you send \s-1GNU\s0 \fBparallel\fR the \fB\s-1TERM\s0\fR signal, \s-1GNU\s0 \fBparallel\fR will
stop spawning new jobs and wait for the remaining jobs to finish. If
you send \s-1GNU\s0 \fBparallel\fR the \fB\s-1TERM\s0\fR signal again, \s-1GNU\s0 \fBparallel\fR
will kill all running jobs and exit.
.PP
\fITermination dependent on job status\fR
.IX Subsection "Termination dependent on job status"
.PP
For certain jobs there is no need to continue if one of the jobs fails
and has an exit code different from 0. \s-1GNU\s0 \fBparallel\fR will stop spawning new jobs
with \fB\-\-halt soon,fail=1\fR:
.PP
.Vb 1
\&  parallel \-j2 \-\-halt soon,fail=1 echo {}\e; exit {} ::: 0 0 1 2 3
.Ve
.PP
Output:
.PP
.Vb 7
\&  0
\&  0
\&  1
\&  parallel: This job failed:
\&  echo 1; exit 1
\&  parallel: Starting no more jobs. Waiting for 1 jobs to finish.
\&  2
.Ve
.PP
With \fB\-\-halt now,fail=1\fR the running jobs will be killed immediately:
.PP
.Vb 1
\&  parallel \-j2 \-\-halt now,fail=1 echo {}\e; exit {} ::: 0 0 1 2 3
.Ve
.PP
Output:
.PP
.Vb 5
\&  0
\&  0
\&  1
\&  parallel: This job failed:
\&  echo 1; exit 1
.Ve
.PP
If \fB\-\-halt\fR is given a percentage this percentage of the jobs must fail
before \s-1GNU\s0 \fBparallel\fR stops spawning more jobs:
.PP
.Vb 2
\&  parallel \-j2 \-\-halt soon,fail=20% echo {}\e; exit {} \e
\&    ::: 0 1 2 3 4 5 6 7 8 9
.Ve
.PP
Output:
.PP
.Vb 11
\&  0
\&  1
\&  parallel: This job failed:
\&  echo 1; exit 1
\&  2
\&  parallel: This job failed:
\&  echo 2; exit 2
\&  parallel: Starting no more jobs. Waiting for 1 jobs to finish.
\&  3
\&  parallel: This job failed:
\&  echo 3; exit 3
.Ve
.PP
If you are looking for success instead of failures, you can use
\&\fBsuccess\fR. This will finish as soon as the first job succeeds:
.PP
.Vb 1
\&  parallel \-j2 \-\-halt now,success=1 echo {}\e; exit {} ::: 1 2 3 0 4 5 6
.Ve
.PP
Output:
.PP
.Vb 6
\&  1
\&  2
\&  3
\&  0
\&  parallel: This job succeeded:
\&  echo 0; exit 0
.Ve
.PP
\&\s-1GNU\s0 \fBparallel\fR can retry the command with \fB\-\-retries\fR. This is useful if a
command fails for unknown reasons now and then.
.PP
.Vb 3
\&  parallel \-k \-\-retries 3 \e
\&    \*(Aqecho tried {} >>/tmp/runs; echo completed {}; exit {}\*(Aq ::: 1 2 0
\&  cat /tmp/runs
.Ve
.PP
Output:
.PP
.Vb 3
\&  completed 1
\&  completed 2
\&  completed 0
\&
\&  tried 1
\&  tried 2
\&  tried 1
\&  tried 2
\&  tried 1
\&  tried 2
\&  tried 0
.Ve
.PP
Note how job 1 and 2 were tried 3 times, but 0 was not retried because it had exit code 0.
.PP
\fITermination signals (advanced)\fR
.IX Subsection "Termination signals (advanced)"
.PP
Using \fB\-\-termseq\fR you can control which signals are sent when killing
children. Normally children will be killed by sending them \fB\s-1SIGTERM\s0\fR,
waiting 200 ms, then another \fB\s-1SIGTERM\s0\fR, waiting 100 ms, then another
\&\fB\s-1SIGTERM\s0\fR, waiting 50 ms, then a \fB\s-1SIGKILL\s0\fR, finally waiting 25 ms
before giving up. It looks like this:
.PP
.Vb 9
\&  show_signals() {
\&    perl \-e \*(Aqfor(keys %SIG) {
\&        $SIG{$_} = eval "sub { print \e"Got $_\e\en\e"; }";
\&      }
\&      while(1){sleep 1}\*(Aq
\&  }
\&  export \-f show_signals
\&  echo | parallel \-\-termseq TERM,200,TERM,100,TERM,50,KILL,25 \e
\&    \-u \-\-timeout 1 show_signals
.Ve
.PP
Output:
.PP
.Vb 3
\&  Got TERM
\&  Got TERM
\&  Got TERM
.Ve
.PP
Or just:
.PP
.Vb 1
\&  echo | parallel \-u \-\-timeout 1 show_signals
.Ve
.PP
Output: Same as above.
.PP
You can change this to \fB\s-1SIGINT\s0\fR, \fB\s-1SIGTERM\s0\fR, \fB\s-1SIGKILL\s0\fR:
.PP
.Vb 2
\&  echo | parallel \-\-termseq INT,200,TERM,100,KILL,25 \e
\&    \-u \-\-timeout 1 show_signals
.Ve
.PP
Output:
.PP
.Vb 2
\&  Got INT
\&  Got TERM
.Ve
.PP
The \fB\s-1SIGKILL\s0\fR does not show because it cannot be caught, and thus the
child dies.
.SS "Limiting the resources"
.IX Subsection "Limiting the resources"
To avoid overloading systems \s-1GNU\s0 \fBparallel\fR can look at the system load
before starting another job:
.PP
.Vb 1
\&  parallel \-\-load 100% echo load is less than {} job per cpu ::: 1
.Ve
.PP
Output:
.PP
.Vb 2
\&  [when then load is less than the number of cpu cores]
\&  load is less than 1 job per cpu
.Ve
.PP
\&\s-1GNU\s0 \fBparallel\fR can also check if the system is swapping.
.PP
.Vb 1
\&  parallel \-\-noswap echo the system is not swapping ::: now
.Ve
.PP
Output:
.PP
.Vb 2
\&  [when then system is not swapping]
\&  the system is not swapping now
.Ve
.PP
Some jobs need a lot of memory, and should only be started when there
is enough memory free. Using \fB\-\-memfree\fR \s-1GNU\s0 \fBparallel\fR can check if
there is enough memory free. Additionally, \s-1GNU\s0 \fBparallel\fR will kill
off the youngest job if the memory free falls below 50% of the
size. The killed job will put back on the queue and retried later.
.PP
.Vb 1
\&  parallel \-\-memfree 1G echo will run if more than 1 GB is ::: free
.Ve
.PP
\&\s-1GNU\s0 \fBparallel\fR can run the jobs with a nice value. This will work both
locally and remotely.
.PP
.Vb 1
\&  parallel \-\-nice 17 echo this is being run with nice \-n ::: 17
.Ve
.PP
Output:
.PP
.Vb 1
\&  this is being run with nice \-n 17
.Ve
.SH "Remote execution"
.IX Header "Remote execution"
\&\s-1GNU\s0 \fBparallel\fR can run jobs on remote servers. It uses \fBssh\fR to
communicate with the remote machines.
.SS "Sshlogin"
.IX Subsection "Sshlogin"
The most basic sshlogin is \fB\-S\fR \fIhost\fR:
.PP
.Vb 1
\&  parallel \-S $SERVER1 echo running on ::: $SERVER1
.Ve
.PP
Output:
.PP
.Vb 1
\&  running on [$SERVER1]
.Ve
.PP
To use a different username prepend the server with \fIusername@\fR:
.PP
.Vb 1
\&  parallel \-S username@$SERVER1 echo running on ::: username@$SERVER1
.Ve
.PP
Output:
.PP
.Vb 1
\&  running on [username@$SERVER1]
.Ve
.PP
The special sshlogin \fB:\fR is the local machine:
.PP
.Vb 1
\&  parallel \-S : echo running on ::: the_local_machine
.Ve
.PP
Output:
.PP
.Vb 1
\&  running on the_local_machine
.Ve
.PP
If \fBssh\fR is not in \f(CW$PATH\fR it can be prepended to \f(CW$SERVER1:\fR
.PP
.Vb 1
\&  parallel \-S \*(Aq/usr/bin/ssh \*(Aq$SERVER1 echo custom ::: ssh
.Ve
.PP
Output:
.PP
.Vb 1
\&  custom ssh
.Ve
.PP
The \fBssh\fR command can also be given using \fB\-\-ssh\fR:
.PP
.Vb 1
\&  parallel \-\-ssh /usr/bin/ssh \-S $SERVER1 echo custom ::: ssh
.Ve
.PP
or by setting \fB\f(CB$PARALLEL_SSH\fB\fR:
.PP
.Vb 2
\&  export PARALLEL_SSH=/usr/bin/ssh
\&  parallel \-S $SERVER1 echo custom ::: ssh
.Ve
.PP
Several servers can be given using multiple \fB\-S\fR:
.PP
.Vb 1
\&  parallel \-S $SERVER1 \-S $SERVER2 echo ::: running on more hosts
.Ve
.PP
Output (the order may be different):
.PP
.Vb 4
\&  running
\&  on
\&  more
\&  hosts
.Ve
.PP
Or they can be separated by \fB,\fR:
.PP
.Vb 1
\&  parallel \-S $SERVER1,$SERVER2 echo ::: running on more hosts
.Ve
.PP
Output: Same as above.
.PP
Or newline:
.PP
.Vb 3
\&  # This gives a \en between $SERVER1 and $SERVER2
\&  SERVERS="\`echo $SERVER1; echo $SERVER2\`"
\&  parallel \-S "$SERVERS" echo ::: running on more hosts
.Ve
.PP
They can also be read from a file (replace \fIuser@\fR with the user on \fB\f(CB$SERVER2\fB\fR):
.PP
.Vb 4
\&  echo $SERVER1 > nodefile
\&  # Force 4 cores, special ssh\-command, username
\&  echo 4//usr/bin/ssh user@$SERVER2 >> nodefile
\&  parallel \-\-sshloginfile nodefile echo ::: running on more hosts
.Ve
.PP
Output: Same as above.
.PP
Every time a job finished, the \fB\-\-sshloginfile\fR will be re-read, so
it is possible to both add and remove hosts while running.
.PP
The special \fB\-\-sshloginfile ..\fR reads from \fB~/.parallel/sshloginfile\fR.
.PP
To force \s-1GNU\s0 \fBparallel\fR to treat a server having a given number of \s-1CPU\s0
cores prepend the number of core followed by \fB/\fR to the sshlogin:
.PP
.Vb 1
\&  parallel \-S 4/$SERVER1 echo force {} cpus on server ::: 4
.Ve
.PP
Output:
.PP
.Vb 1
\&  force 4 cpus on server
.Ve
.PP
Servers can be put into groups by prepending \fI\f(CI@groupname\fI\fR to the
server and the group can then be selected by appending \fI\f(CI@groupname\fI\fR to
the argument if using \fB\-\-hostgroup\fR:
.PP
.Vb 2
\&  parallel \-\-hostgroup \-S @grp1/$SERVER1 \-S @grp2/$SERVER2 echo {} \e
\&    ::: run_on_grp1@grp1 run_on_grp2@grp2
.Ve
.PP
Output:
.PP
.Vb 2
\&  run_on_grp1
\&  run_on_grp2
.Ve
.PP
A host can be in multiple groups by separating the groups with \fB+\fR, and
you can force \s-1GNU\s0 \fBparallel\fR to limit the groups on which the command
can be run with \fB\-S\fR \fI\f(CI@groupname\fI\fR:
.PP
.Vb 2
\&  parallel \-S @grp1 \-S @grp1+grp2/$SERVER1 \-S @grp2/SERVER2 echo {} \e
\&    ::: run_on_grp1 also_grp1
.Ve
.PP
Output:
.PP
.Vb 2
\&  run_on_grp1
\&  also_grp1
.Ve
.SS "Transferring files"
.IX Subsection "Transferring files"
\&\s-1GNU\s0 \fBparallel\fR can transfer the files to be processed to the remote
host. It does that using rsync.
.PP
.Vb 2
\&  echo This is input_file > input_file
\&  parallel \-S $SERVER1 \-\-transferfile {} cat ::: input_file
.Ve
.PP
Output:
.PP
.Vb 1
\&  This is input_file
.Ve
.PP
If the files are processed into another file, the resulting file can be
transferred back:
.PP
.Vb 4
\&  echo This is input_file > input_file
\&  parallel \-S $SERVER1 \-\-transferfile {} \-\-return {}.out \e
\&    cat {} ">"{}.out ::: input_file
\&  cat input_file.out
.Ve
.PP
Output: Same as above.
.PP
To remove the input and output file on the remote server use \fB\-\-cleanup\fR:
.PP
.Vb 4
\&  echo This is input_file > input_file
\&  parallel \-S $SERVER1 \-\-transferfile {} \-\-return {}.out \-\-cleanup \e
\&    cat {} ">"{}.out ::: input_file
\&  cat input_file.out
.Ve
.PP
Output: Same as above.
.PP
There is a shorthand for \fB\-\-transferfile {} \-\-return \-\-cleanup\fR called \fB\-\-trc\fR:
.PP
.Vb 3
\&  echo This is input_file > input_file
\&  parallel \-S $SERVER1 \-\-trc {}.out cat {} ">"{}.out ::: input_file
\&  cat input_file.out
.Ve
.PP
Output: Same as above.
.PP
Some jobs need a common database for all jobs. \s-1GNU\s0 \fBparallel\fR can
transfer that using \fB\-\-basefile\fR which will transfer the file before the
first job:
.PP
.Vb 3
\&  echo common data > common_file
\&  parallel \-\-basefile common_file \-S $SERVER1 \e
\&    cat common_file\e; echo {} ::: foo
.Ve
.PP
Output:
.PP
.Vb 2
\&  common data
\&  foo
.Ve
.PP
To remove it from the remote host after the last job use \fB\-\-cleanup\fR.
.SS "Working dir"
.IX Subsection "Working dir"
The default working dir on the remote machines is the login dir. This
can be changed with \fB\-\-workdir\fR \fImydir\fR.
.PP
Files transferred using \fB\-\-transferfile\fR and \fB\-\-return\fR will be relative
to \fImydir\fR on remote computers, and the command will be executed in
the dir \fImydir\fR.
.PP
The special \fImydir\fR value \fB...\fR will create working dirs under
\&\fB~/.parallel/tmp\fR on the remote computers. If \fB\-\-cleanup\fR is given
these dirs will be removed.
.PP
The special \fImydir\fR value \fB.\fR uses the current working dir.  If the
current working dir is beneath your home dir, the value \fB.\fR is
treated as the relative path to your home dir. This means that if your
home dir is different on remote computers (e.g. if your login is
different) the relative path will still be relative to your home dir.
.PP
.Vb 3
\&  parallel \-S $SERVER1 pwd ::: ""
\&  parallel \-\-workdir . \-S $SERVER1 pwd ::: ""
\&  parallel \-\-workdir ... \-S $SERVER1 pwd ::: ""
.Ve
.PP
Output:
.PP
.Vb 3
\&  [the login dir on $SERVER1]
\&  [current dir relative on $SERVER1]
\&  [a dir in ~/.parallel/tmp/...]
.Ve
.SS "Avoid overloading sshd"
.IX Subsection "Avoid overloading sshd"
If many jobs are started on the same server, \fBsshd\fR can be
overloaded. \s-1GNU\s0 \fBparallel\fR can insert a delay between each job run on
the same server:
.PP
.Vb 1
\&  parallel \-S $SERVER1 \-\-sshdelay 0.2 echo ::: 1 2 3
.Ve
.PP
Output (the order may be different):
.PP
.Vb 3
\&  1
\&  2
\&  3
.Ve
.PP
\&\fBsshd\fR will be less overloaded if using \fB\-\-controlmaster\fR, which will
multiplex ssh connections:
.PP
.Vb 1
\&  parallel \-\-controlmaster \-S $SERVER1 echo ::: 1 2 3
.Ve
.PP
Output: Same as above.
.SS "Ignore hosts that are down"
.IX Subsection "Ignore hosts that are down"
In clusters with many hosts a few of them are often down. \s-1GNU\s0 \fBparallel\fR
can ignore those hosts. In this case the host 173.194.32.46 is down:
.PP
.Vb 1
\&  parallel \-\-filter\-hosts \-S 173.194.32.46,$SERVER1 echo ::: bar
.Ve
.PP
Output:
.PP
.Vb 1
\&  bar
.Ve
.SS "Running the same commands on all hosts"
.IX Subsection "Running the same commands on all hosts"
\&\s-1GNU\s0 \fBparallel\fR can run the same command on all the hosts:
.PP
.Vb 1
\&  parallel \-\-onall \-S $SERVER1,$SERVER2 echo ::: foo bar
.Ve
.PP
Output (the order may be different):
.PP
.Vb 4
\&  foo
\&  bar
\&  foo
\&  bar
.Ve
.PP
Often you will just want to run a single command on all hosts with out
arguments. \fB\-\-nonall\fR is a no argument \fB\-\-onall\fR:
.PP
.Vb 1
\&  parallel \-\-nonall \-S $SERVER1,$SERVER2 echo foo bar
.Ve
.PP
Output:
.PP
.Vb 2
\&  foo bar
\&  foo bar
.Ve
.PP
When \fB\-\-tag\fR is used with \fB\-\-nonall\fR and \fB\-\-onall\fR the \fB\-\-tagstring\fR is the host:
.PP
.Vb 1
\&  parallel \-\-nonall \-\-tag \-S $SERVER1,$SERVER2 echo foo bar
.Ve
.PP
Output (the order may be different):
.PP
.Vb 2
\&  $SERVER1 foo bar
\&  $SERVER2 foo bar
.Ve
.PP
\&\fB\-\-jobs\fR sets the number of servers to log in to in parallel.
.SS "Transferring environment variables and functions"
.IX Subsection "Transferring environment variables and functions"
\&\fBenv_parallel\fR is a shell function that transfers all aliases,
functions, variables, and arrays. You active it by running:
.PP
.Vb 1
\&  source \`which env_parallel.bash\`
.Ve
.PP
Replace \fBbash\fR with the shell you use.
.PP
Now you can use \fBenv_parallel\fR instead of \fBparallel\fR and still have
your environment:
.PP
.Vb 3
\&  alias myecho=echo
\&  myvar="Joe\*(Aqs var is"
\&  env_parallel \-S $SERVER1 \*(Aqmyecho $myvar\*(Aq ::: green
.Ve
.PP
Output:
.PP
.Vb 1
\&  Joe\*(Aqs var is green
.Ve
.PP
The disadvantage is that if your environment is huge \fBenv_parallel\fR
will fail.
.PP
When \fBenv_parallel\fR fails, you can still use \fB\-\-env\fR to tell \s-1GNU\s0
\&\fBparallel\fR to transfer an environment variable to the remote system.
.PP
.Vb 3
\&  MYVAR=\*(Aqfoo bar\*(Aq
\&  export MYVAR
\&  parallel \-\-env MYVAR \-S $SERVER1 echo \*(Aq$MYVAR\*(Aq ::: baz
.Ve
.PP
Output:
.PP
.Vb 1
\&  foo bar baz
.Ve
.PP
This works for functions, too, if your shell is Bash:
.PP
.Vb 6
\&  # This only works in Bash
\&  my_func() {
\&    echo in my_func $1
\&  }
\&  export \-f my_func
\&  parallel \-\-env my_func \-S $SERVER1 my_func ::: baz
.Ve
.PP
Output:
.PP
.Vb 1
\&  in my_func baz
.Ve
.PP
\&\s-1GNU\s0 \fBparallel\fR can copy all user defined variables and functions to
the remote system. It just needs to record which ones to ignore in
\&\fB~/.parallel/ignored_vars\fR. Do that by running this once:
.PP
.Vb 2
\&  parallel \-\-record\-env
\&  cat ~/.parallel/ignored_vars
.Ve
.PP
Output:
.PP
.Vb 1
\&  [list of variables to ignore \- including $PATH and $HOME]
.Ve
.PP
Now all other variables and functions defined will be copied when
using \fB\-\-env _\fR.
.PP
.Vb 7
\&  # The function is only copied if using Bash
\&  my_func2() {
\&    echo in my_func2 $VAR $1
\&  }
\&  export \-f my_func2
\&  VAR=foo
\&  export VAR
\&
\&  parallel \-\-env _ \-S $SERVER1 \*(Aqecho $VAR; my_func2\*(Aq ::: bar
.Ve
.PP
Output:
.PP
.Vb 2
\&  foo
\&  in my_func2 foo bar
.Ve
.PP
If you use \fBenv_parallel\fR the variables, functions, and aliases do
not even need to be exported to be copied:
.PP
.Vb 6
\&  NOT=\*(Aqnot exported var\*(Aq
\&  alias myecho=echo
\&  not_ex() {
\&    myecho in not_exported_func $NOT $1
\&  }
\&  env_parallel \-\-env _ \-S $SERVER1 \*(Aqecho $NOT; not_ex\*(Aq ::: bar
.Ve
.PP
Output:
.PP
.Vb 2
\&  not exported var
\&  in not_exported_func not exported var bar
.Ve
.SS "Showing what is actually run"
.IX Subsection "Showing what is actually run"
\&\fB\-\-verbose\fR will show the command that would be run on the local
machine.
.PP
When using \fB\-\-cat\fR, \fB\-\-pipepart\fR, or when a job is run on a remote
machine, the command is wrapped with helper scripts. \fB\-vv\fR shows all
of this.
.PP
.Vb 1
\&  parallel \-vv \-\-pipepart \-\-block 1M wc :::: num30000
.Ve
.PP
Output:
.PP
.Vb 5
\&  <num30000 perl \-e \*(Aqwhile(@ARGV) { sysseek(STDIN,shift,0) || die;
\&  $left = shift; while($read = sysread(STDIN,$buf, ($left > 131072
\&  ? 131072 : $left))){ $left \-= $read; syswrite(STDOUT,$buf); } }\*(Aq
\&  0 0 0 168894 | (wc)
\&    30000   30000  168894
.Ve
.PP
When the command gets more complex, the output is so hard to read,
that it is only useful for debugging:
.PP
.Vb 6
\&  my_func3() {
\&    echo in my_func $1 > $1.out
\&  }
\&  export \-f my_func3
\&  parallel \-vv \-\-workdir ... \-\-nice 17 \-\-env _ \-\-trc {}.out \e
\&    \-S $SERVER1 my_func3 {} ::: abc\-file
.Ve
.PP
Output will be similar to:
.PP
.Vb 10
\&  ( ssh server \-\- mkdir \-p ./.parallel/tmp/aspire\-1928520\-1;rsync
\&  \-\-protocol 30 \-rlDzR \-essh ./abc\-file 
\&  server:./.parallel/tmp/aspire\-1928520\-1 );ssh server \-\- exec perl \-e 
\&  \e\*(Aq\*(Aq@GNU_Parallel=("use","IPC::Open3;","use","MIME::Base64");
\&  eval"@GNU_Parallel";my$eval=decode_base64(join"",@ARGV);eval$eval;\*(Aq\e\*(Aq
\&  c3lzdGVtKCJta2RpciIsIi1wIiwiLS0iLCIucGFyYWxsZWwvdG1wL2FzcGlyZS0xOTI4N
\&  TsgY2hkaXIgIi5wYXJhbGxlbC90bXAvYXNwaXJlLTE5Mjg1MjAtMSIgfHxwcmludChTVE
\&  BhcmFsbGVsOiBDYW5ub3QgY2hkaXIgdG8gLnBhcmFsbGVsL3RtcC9hc3BpcmUtMTkyODU
\&  iKSAmJiBleGl0IDI1NTskRU5WeyJPTERQV0QifT0iL2hvbWUvdGFuZ2UvcHJpdmF0L3Bh
\&  IjskRU5WeyJQQVJBTExFTF9QSUQifT0iMTkyODUyMCI7JEVOVnsiUEFSQUxMRUxfU0VRI
\&  0BiYXNoX2Z1bmN0aW9ucz1xdyhteV9mdW5jMyk7IGlmKCRFTlZ7IlNIRUxMIn09fi9jc2
\&  ByaW50IFNUREVSUiAiQ1NIL1RDU0ggRE8gTk9UIFNVUFBPUlQgbmV3bGluZXMgSU4gVkF
\&  TL0ZVTkNUSU9OUy4gVW5zZXQgQGJhc2hfZnVuY3Rpb25zXG4iOyBleGVjICJmYWxzZSI7
\&  YXNoZnVuYyA9ICJteV9mdW5jMygpIHsgIGVjaG8gaW4gbXlfZnVuYyBcJDEgPiBcJDEub
\&  Xhwb3J0IC1mIG15X2Z1bmMzID4vZGV2L251bGw7IjtAQVJHVj0ibXlfZnVuYzMgYWJjLW
\&  RzaGVsbD0iJEVOVntTSEVMTH0iOyR0bXBkaXI9Ii90bXAiOyRuaWNlPTE3O2RveyRFTlZ
\&  MRUxfVE1QfT0kdG1wZGlyLiIvcGFyIi5qb2luIiIsbWFweygwLi45LCJhIi4uInoiLCJB
\&  KVtyYW5kKDYyKV19KDEuLjUpO313aGlsZSgtZSRFTlZ7UEFSQUxMRUxfVE1QfSk7JFNJ
\&  fT1zdWJ7JGRvbmU9MTt9OyRwaWQ9Zm9yazt1bmxlc3MoJHBpZCl7c2V0cGdycDtldmFse
\&  W9yaXR5KDAsMCwkbmljZSl9O2V4ZWMkc2hlbGwsIi1jIiwoJGJhc2hmdW5jLiJAQVJHVi
\&  JleGVjOiQhXG4iO31kb3skcz0kczwxPzAuMDAxKyRzKjEuMDM6JHM7c2VsZWN0KHVuZGV
\&  mLHVuZGVmLCRzKTt9dW50aWwoJGRvbmV8fGdldHBwaWQ9PTEpO2tpbGwoU0lHSFVQLC0k
\&  dW5sZXNzJGRvbmU7d2FpdDtleGl0KCQ/JjEyNz8xMjgrKCQ/JjEyNyk6MSskPz4+OCk=;
\&  _EXIT_status=$?; mkdir \-p ./.; rsync \-\-protocol 30 \-\-rsync\-path=cd\e
\&  ./.parallel/tmp/aspire\-1928520\-1/./.\e;\e rsync \-rlDzR \-essh
\&  server:./abc\-file.out ./.;ssh server \-\- \e(rm\e \-f\e
\&  ./.parallel/tmp/aspire\-1928520\-1/abc\-file\e;\e sh\e \-c\e \e\*(Aqrmdir\e
\&  ./.parallel/tmp/aspire\-1928520\-1/\e ./.parallel/tmp/\e ./.parallel/\e
\&  2\e>/dev/null\e\*(Aq\e;rm\e \-rf\e ./.parallel/tmp/aspire\-1928520\-1\e;\e);ssh
\&  server \-\- \e(rm\e \-f\e ./.parallel/tmp/aspire\-1928520\-1/abc\-file.out\e;\e
\&  sh\e \-c\e \e\*(Aqrmdir\e ./.parallel/tmp/aspire\-1928520\-1/\e ./.parallel/tmp/\e
\&  ./.parallel/\e 2\e>/dev/null\e\*(Aq\e;rm\e \-rf\e 
\&  ./.parallel/tmp/aspire\-1928520\-1\e;\e);ssh server \-\- rm \-rf 
\&  .parallel/tmp/aspire\-1928520\-1; exit $_EXIT_status;
.Ve
.SH "Saving output to shell variables (advanced)"
.IX Header "Saving output to shell variables (advanced)"
\&\s-1GNU\s0 \fBparset\fR will set shell variables to the output of \s-1GNU\s0
\&\fBparallel\fR. \s-1GNU\s0 \fBparset\fR has one important limitation: It cannot be
part of a pipe. In particular this means it cannot read anything from
standard input (stdin) or pipe output to another program.
.PP
To use \s-1GNU\s0 \fBparset\fR prepend command with destination variables:
.PP
.Vb 3
\&  parset myvar1,myvar2 echo ::: a b
\&  echo $myvar1
\&  echo $myvar2
.Ve
.PP
Output:
.PP
.Vb 2
\&  a
\&  b
.Ve
.PP
If you only give a single variable, it will be treated as an array:
.PP
.Vb 2
\&  parset myarray seq {} 5 ::: 1 2 3
\&  echo "${myarray[1]}"
.Ve
.PP
Output:
.PP
.Vb 4
\&  2
\&  3
\&  4
\&  5
.Ve
.PP
The commands to run can be an array:
.PP
.Vb 4
\&  cmd=("echo \*(Aq<<joe  \e"double  space\e"  cartoon>>\*(Aq" "pwd")
\&  parset data ::: "${cmd[@]}"
\&  echo "${data[0]}"
\&  echo "${data[1]}"
.Ve
.PP
Output:
.PP
.Vb 2
\&  <<joe  "double  space"  cartoon>>
\&  [current dir]
.Ve
.SH "Saving to an SQL base (advanced)"
.IX Header "Saving to an SQL base (advanced)"
\&\s-1GNU\s0 \fBparallel\fR can save into an \s-1SQL\s0 base. Point \s-1GNU\s0 \fBparallel\fR to a
table and it will put the joblog there together with the variables and
the output each in their own column.
.SS "\s-1CSV\s0 as \s-1SQL\s0 base"
.IX Subsection "CSV as SQL base"
The simplest is to use a \s-1CSV\s0 file as the storage table:
.PP
.Vb 3
\&  parallel \-\-sqlandworker csv:///%2Ftmp/log.csv \e
\&    seq ::: 10 ::: 12 13 14
\&  cat /tmp/log.csv
.Ve
.PP
Note how '/' in the path must be written as \f(CW%2F\fR.
.PP
Output will be similar to:
.PP
.Vb 10
\&  Seq,Host,Starttime,JobRuntime,Send,Receive,Exitval,_Signal,
\&    Command,V1,V2,Stdout,Stderr
\&  1,:,1458254498.254,0.069,0,9,0,0,"seq 10 12",10,12,"10
\&  11
\&  12
\&  ",
\&  2,:,1458254498.278,0.080,0,12,0,0,"seq 10 13",10,13,"10
\&  11
\&  12
\&  13
\&  ",
\&  3,:,1458254498.301,0.083,0,15,0,0,"seq 10 14",10,14,"10
\&  11
\&  12
\&  13
\&  14
\&  ",
.Ve
.PP
A proper \s-1CSV\s0 reader (like LibreOffice or R's read.csv) will read this
format correctly \- even with fields containing newlines as above.
.PP
If the output is big you may want to put it into files using \fB\-\-results\fR:
.PP
.Vb 3
\&  parallel \-\-results outdir \-\-sqlandworker csv:///%2Ftmp/log2.csv \e
\&    seq ::: 10 ::: 12 13 14
\&  cat /tmp/log2.csv
.Ve
.PP
Output will be similar to:
.PP
.Vb 8
\&  Seq,Host,Starttime,JobRuntime,Send,Receive,Exitval,_Signal,
\&    Command,V1,V2,Stdout,Stderr
\&  1,:,1458824738.287,0.029,0,9,0,0,
\&    "seq 10 12",10,12,outdir/1/10/2/12/stdout,outdir/1/10/2/12/stderr
\&  2,:,1458824738.298,0.025,0,12,0,0,
\&    "seq 10 13",10,13,outdir/1/10/2/13/stdout,outdir/1/10/2/13/stderr
\&  3,:,1458824738.309,0.026,0,15,0,0,
\&    "seq 10 14",10,14,outdir/1/10/2/14/stdout,outdir/1/10/2/14/stderr
.Ve
.SS "\s-1DBURL\s0 as table"
.IX Subsection "DBURL as table"
The \s-1CSV\s0 file is an example of a \s-1DBURL.\s0
.PP
\&\s-1GNU\s0 \fBparallel\fR uses a \s-1DBURL\s0 to address the table. A \s-1DBURL\s0 has this format:
.PP
.Vb 1
\&  vendor://[[user][:password]@][host][:port]/[database[/table]
.Ve
.PP
Example:
.PP
.Vb 4
\&  mysql://scott:tiger@my.example.com/mydatabase/mytable
\&  postgresql://scott:tiger@pg.example.com/mydatabase/mytable
\&  sqlite3:///%2Ftmp%2Fmydatabase/mytable
\&  csv:///%2Ftmp/log.csv
.Ve
.PP
To refer to \fB/tmp/mydatabase\fR with \fBsqlite\fR or \fBcsv\fR you need to
encode the \fB/\fR as \fB\f(CB%2F\fB\fR.
.PP
Run a job using \fBsqlite\fR on \fBmytable\fR in \fB/tmp/mydatabase\fR:
.PP
.Vb 3
\&  DBURL=sqlite3:///%2Ftmp%2Fmydatabase
\&  DBURLTABLE=$DBURL/mytable
\&  parallel \-\-sqlandworker $DBURLTABLE echo ::: foo bar ::: baz quuz
.Ve
.PP
To see the result:
.PP
.Vb 1
\&  sql $DBURL \*(AqSELECT * FROM mytable ORDER BY Seq;\*(Aq
.Ve
.PP
Output will be similar to:
.PP
.Vb 10
\&  Seq|Host|Starttime|JobRuntime|Send|Receive|Exitval|_Signal|
\&    Command|V1|V2|Stdout|Stderr
\&  1|:|1451619638.903|0.806||8|0|0|echo foo baz|foo|baz|foo baz
\&  |
\&  2|:|1451619639.265|1.54||9|0|0|echo foo quuz|foo|quuz|foo quuz
\&  |
\&  3|:|1451619640.378|1.43||8|0|0|echo bar baz|bar|baz|bar baz
\&  |
\&  4|:|1451619641.473|0.958||9|0|0|echo bar quuz|bar|quuz|bar quuz
\&  |
.Ve
.PP
The first columns are well known from \fB\-\-joblog\fR. \fBV1\fR and \fBV2\fR are
data from the input sources. \fBStdout\fR and \fBStderr\fR are standard
output and standard error, respectively.
.SS "Using multiple workers"
.IX Subsection "Using multiple workers"
Using an \s-1SQL\s0 base as storage costs overhead in the order of 1 second
per job.
.PP
One of the situations where it makes sense is if you have multiple
workers.
.PP
You can then have a single master machine that submits jobs to the \s-1SQL\s0
base (but does not do any of the work):
.PP
.Vb 1
\&  parallel \-\-sqlmaster $DBURLTABLE echo ::: foo bar ::: baz quuz
.Ve
.PP
On the worker machines you run exactly the same command except you
replace \fB\-\-sqlmaster\fR with \fB\-\-sqlworker\fR.
.PP
.Vb 1
\&  parallel \-\-sqlworker $DBURLTABLE echo ::: foo bar ::: baz quuz
.Ve
.PP
To run a master and a worker on the same machine use \fB\-\-sqlandworker\fR
as shown earlier.
.SH "\-\-pipe"
.IX Header "--pipe"
The \fB\-\-pipe\fR functionality puts \s-1GNU\s0 \fBparallel\fR in a different mode:
Instead of treating the data on stdin (standard input) as arguments
for a command to run, the data will be sent to stdin (standard input)
of the command.
.PP
The typical situation is:
.PP
.Vb 1
\&  command_A | command_B | command_C
.Ve
.PP
where command_B is slow, and you want to speed up command_B.
.SS "Chunk size"
.IX Subsection "Chunk size"
By default \s-1GNU\s0 \fBparallel\fR will start an instance of command_B, read a
chunk of 1 \s-1MB,\s0 and pass that to the instance. Then start another
instance, read another chunk, and pass that to the second instance.
.PP
.Vb 1
\&  cat num1000000 | parallel \-\-pipe wc
.Ve
.PP
Output (the order may be different):
.PP
.Vb 7
\&  165668  165668 1048571
\&  149797  149797 1048579
\&  149796  149796 1048572
\&  149797  149797 1048579
\&  149797  149797 1048579
\&  149796  149796 1048572
\&   85349   85349  597444
.Ve
.PP
The size of the chunk is not exactly 1 \s-1MB\s0 because \s-1GNU\s0 \fBparallel\fR only
passes full lines \- never half a line, thus the blocksize is only
1 \s-1MB\s0 on average. You can change the block size to 2 \s-1MB\s0 with \fB\-\-block\fR:
.PP
.Vb 1
\&  cat num1000000 | parallel \-\-pipe \-\-block 2M wc
.Ve
.PP
Output (the order may be different):
.PP
.Vb 4
\&  315465  315465 2097150
\&  299593  299593 2097151
\&  299593  299593 2097151
\&   85349   85349  597444
.Ve
.PP
\&\s-1GNU\s0 \fBparallel\fR treats each line as a record. If the order of records
is unimportant (e.g. you need all lines processed, but you do not care
which is processed first), then you can use \fB\-\-roundrobin\fR. Without
\&\fB\-\-roundrobin\fR \s-1GNU\s0 \fBparallel\fR will start a command per block; with
\&\fB\-\-roundrobin\fR only the requested number of jobs will be started
(\fB\-\-jobs\fR). The records will then be distributed between the running
jobs:
.PP
.Vb 1
\&  cat num1000000 | parallel \-\-pipe \-j4 \-\-roundrobin wc
.Ve
.PP
Output will be similar to:
.PP
.Vb 4
\&  149797  149797 1048579
\&  299593  299593 2097151
\&  315465  315465 2097150
\&  235145  235145 1646016
.Ve
.PP
One of the 4 instances got a single record, 2 instances got 2 full
records each, and one instance got 1 full and 1 partial record.
.SS "Records"
.IX Subsection "Records"
\&\s-1GNU\s0 \fBparallel\fR sees the input as records. The default record is a single
line.
.PP
Using \fB\-N140000\fR \s-1GNU\s0 \fBparallel\fR will read 140000 records at a time:
.PP
.Vb 1
\&  cat num1000000 | parallel \-\-pipe \-N140000 wc
.Ve
.PP
Output (the order may be different):
.PP
.Vb 8
\&  140000  140000  868895
\&  140000  140000  980000
\&  140000  140000  980000
\&  140000  140000  980000
\&  140000  140000  980000
\&  140000  140000  980000
\&  140000  140000  980000
\&   20000   20000  140001
.Ve
.PP
Note how that the last job could not get the full 140000 lines, but
only 20000 lines.
.PP
If a record is 75 lines \fB\-L\fR can be used:
.PP
.Vb 1
\&  cat num1000000 | parallel \-\-pipe \-L75 wc
.Ve
.PP
Output (the order may be different):
.PP
.Vb 8
\&  165600  165600 1048095
\&  149850  149850 1048950
\&  149775  149775 1048425
\&  149775  149775 1048425
\&  149850  149850 1048950
\&  149775  149775 1048425
\&   85350   85350  597450
\&      25      25     176
.Ve
.PP
Note how \s-1GNU\s0 \fBparallel\fR still reads a block of around 1 \s-1MB\s0; but
instead of passing full lines to \fBwc\fR it passes full 75 lines at a
time. This of course does not hold for the last job (which in this
case got 25 lines).
.SS "Fixed length records"
.IX Subsection "Fixed length records"
Fixed length records can be processed by setting \fB\-\-recend ''\fR and
\&\fB\-\-block \f(BIrecordsize\fB\fR. A header of size \fIn\fR can be processed with
\&\fB\-\-header .{\f(BIn\fB}\fR.
.PP
Here is how to process a file with a 4\-byte header and a 3\-byte record
size:
.PP
.Vb 2
\&  cat fixedlen | parallel \-\-pipe \-\-header .{4} \-\-block 3 \-\-recend \*(Aq\*(Aq \e
\&    \*(Aqecho start; cat; echo\*(Aq
.Ve
.PP
Output:
.PP
.Vb 6
\&  start
\&  HHHHAAA
\&  start
\&  HHHHCCC
\&  start
\&  HHHHBBB
.Ve
.PP
It may be more efficient to increase \fB\-\-block\fR to a multiplum of the
record size.
.SS "Record separators"
.IX Subsection "Record separators"
\&\s-1GNU\s0 \fBparallel\fR uses separators to determine where two records split.
.PP
\&\fB\-\-recstart\fR gives the string that starts a record; \fB\-\-recend\fR gives the
string that ends a record. The default is \fB\-\-recend '\en'\fR (newline).
.PP
If both \fB\-\-recend\fR and \fB\-\-recstart\fR are given, then the record will only
split if the recend string is immediately followed by the recstart
string.
.PP
Here the \fB\-\-recend\fR is set to \fB', '\fR:
.PP
.Vb 2
\&  echo /foo, bar/, /baz, qux/, | \e
\&    parallel \-kN1 \-\-recend \*(Aq, \*(Aq \-\-pipe echo JOB{#}\e;cat\e;echo END
.Ve
.PP
Output:
.PP
.Vb 9
\&  JOB1
\&  /foo, END
\&  JOB2
\&  bar/, END
\&  JOB3
\&  /baz, END
\&  JOB4
\&  qux/,
\&  END
.Ve
.PP
Here the \fB\-\-recstart\fR is set to \fB/\fR:
.PP
.Vb 2
\&  echo /foo, bar/, /baz, qux/, | \e
\&    parallel \-kN1 \-\-recstart / \-\-pipe echo JOB{#}\e;cat\e;echo END
.Ve
.PP
Output:
.PP
.Vb 9
\&  JOB1
\&  /foo, barEND
\&  JOB2
\&  /, END
\&  JOB3
\&  /baz, quxEND
\&  JOB4
\&  /,
\&  END
.Ve
.PP
Here both \fB\-\-recend\fR and \fB\-\-recstart\fR are set:
.PP
.Vb 3
\&  echo /foo, bar/, /baz, qux/, | \e
\&    parallel \-kN1 \-\-recend \*(Aq, \*(Aq \-\-recstart / \-\-pipe \e
\&    echo JOB{#}\e;cat\e;echo END
.Ve
.PP
Output:
.PP
.Vb 5
\&  JOB1
\&  /foo, bar/, END
\&  JOB2
\&  /baz, qux/,
\&  END
.Ve
.PP
Note the difference between setting one string and setting both strings.
.PP
With \fB\-\-regexp\fR the \fB\-\-recend\fR and \fB\-\-recstart\fR will be treated as
a regular expression:
.PP
.Vb 3
\&  echo foo,bar,_baz,_\|_qux, | \e
\&    parallel \-kN1 \-\-regexp \-\-recend ,_+ \-\-pipe \e
\&    echo JOB{#}\e;cat\e;echo END
.Ve
.PP
Output:
.PP
.Vb 7
\&  JOB1
\&  foo,bar,_END
\&  JOB2
\&  baz,_\|_END
\&  JOB3
\&  qux,
\&  END
.Ve
.PP
\&\s-1GNU\s0 \fBparallel\fR can remove the record separators with
\&\fB\-\-remove\-rec\-sep\fR/\fB\-\-rrs\fR:
.PP
.Vb 3
\&  echo foo,bar,_baz,_\|_qux, | \e
\&    parallel \-kN1 \-\-rrs \-\-regexp \-\-recend ,_+ \-\-pipe \e
\&    echo JOB{#}\e;cat\e;echo END
.Ve
.PP
Output:
.PP
.Vb 7
\&  JOB1
\&  foo,barEND
\&  JOB2
\&  bazEND
\&  JOB3
\&  qux,
\&  END
.Ve
.SS "Header"
.IX Subsection "Header"
If the input data has a header, the header can be repeated for each
job by matching the header with \fB\-\-header\fR. If headers start with
\&\fB%\fR you can do this:
.PP
.Vb 2
\&  cat num_%header | \e
\&    parallel \-\-header \*(Aq(%.*\en)*\*(Aq \-\-pipe \-N3 echo JOB{#}\e;cat
.Ve
.PP
Output (the order may be different):
.PP
.Vb 10
\&  JOB1
\&  %head1
\&  %head2
\&  1
\&  2
\&  3
\&  JOB2
\&  %head1
\&  %head2
\&  4
\&  5
\&  6
\&  JOB3
\&  %head1
\&  %head2
\&  7
\&  8
\&  9
\&  JOB4
\&  %head1
\&  %head2
\&  10
.Ve
.PP
If the header is 2 lines, \fB\-\-header\fR 2 will work:
.PP
.Vb 1
\&  cat num_%header | parallel \-\-header 2 \-\-pipe \-N3 echo JOB{#}\e;cat
.Ve
.PP
Output: Same as above.
.SS "\-\-pipepart"
.IX Subsection "--pipepart"
\&\fB\-\-pipe\fR is not very efficient. It maxes out at around 500
MB/s. \fB\-\-pipepart\fR can easily deliver 5 GB/s. But there are a few
limitations. The input has to be a normal file (not a pipe) given by
\&\fB\-a\fR or \fB::::\fR and \fB\-L\fR/\fB\-l\fR/\fB\-N\fR do not work. \fB\-\-recend\fR and
\&\fB\-\-recstart\fR, however, \fIdo\fR work, and records can often be split on
that alone.
.PP
.Vb 1
\&  parallel \-\-pipepart \-a num1000000 \-\-block 3m wc
.Ve
.PP
Output (the order may be different):
.PP
.Vb 3
\& 444443  444444 3000002
\& 428572  428572 3000004
\& 126985  126984  888890
.Ve
.SH "Shebang"
.IX Header "Shebang"
.SS "Input data and parallel command in the same file"
.IX Subsection "Input data and parallel command in the same file"
\&\s-1GNU\s0 \fBparallel\fR is often called as this:
.PP
.Vb 1
\&  cat input_file | parallel command
.Ve
.PP
With \fB\-\-shebang\fR the \fIinput_file\fR and \fBparallel\fR can be combined into the same script.
.PP
\&\s-1UNIX\s0 shell scripts start with a shebang line like this:
.PP
.Vb 1
\&  #!/bin/bash
.Ve
.PP
\&\s-1GNU\s0 \fBparallel\fR can do that, too. With \fB\-\-shebang\fR the arguments can be
listed in the file. The \fBparallel\fR command is the first line of the
script:
.PP
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang \-r echo
\&
\&  foo
\&  bar
\&  baz
.Ve
.PP
Output (the order may be different):
.PP
.Vb 3
\&  foo
\&  bar
\&  baz
.Ve
.SS "Parallelizing existing scripts"
.IX Subsection "Parallelizing existing scripts"
\&\s-1GNU\s0 \fBparallel\fR is often called as this:
.PP
.Vb 2
\&  cat input_file | parallel command
\&  parallel command ::: foo bar
.Ve
.PP
If \fBcommand\fR is a script, \fBparallel\fR can be combined into a single
file so this will run the script in parallel:
.PP
.Vb 2
\&  cat input_file | command
\&  command foo bar
.Ve
.PP
This \fBperl\fR script \fBperl_echo\fR works like \fBecho\fR:
.PP
.Vb 1
\&  #!/usr/bin/perl
\&
\&  print "@ARGV\en"
.Ve
.PP
It can be called as this:
.PP
.Vb 1
\&  parallel perl_echo ::: foo bar
.Ve
.PP
By changing the \fB#!\fR\-line it can be run in parallel:
.PP
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang\-wrap /usr/bin/perl
\&
\&  print "@ARGV\en"
.Ve
.PP
Thus this will work:
.PP
.Vb 1
\&  perl_echo foo bar
.Ve
.PP
Output (the order may be different):
.PP
.Vb 2
\&  foo
\&  bar
.Ve
.PP
This technique can be used for:
.IP "Perl:" 9
.IX Item "Perl:"
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang\-wrap /usr/bin/perl
\&  
\&  print "Arguments @ARGV\en";
.Ve
.IP "Python:" 9
.IX Item "Python:"
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang\-wrap /usr/bin/python
\&  
\&  import sys
\&  print \*(AqArguments\*(Aq, str(sys.argv)
.Ve
.IP "Bash/sh/zsh/Korn shell:" 9
.IX Item "Bash/sh/zsh/Korn shell:"
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang\-wrap /bin/bash
\&  
\&  echo Arguments "$@"
.Ve
.IP "csh:" 9
.IX Item "csh:"
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang\-wrap /bin/csh
\&  
\&  echo Arguments "$argv"
.Ve
.IP "Tcl:" 9
.IX Item "Tcl:"
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang\-wrap /usr/bin/tclsh
\&  
\&  puts "Arguments $argv"
.Ve
.IP "R:" 9
.IX Item "R:"
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang\-wrap /usr/bin/Rscript \-\-vanilla \-\-slave
\&  
\&  args <\- commandArgs(trailingOnly = TRUE)
\&  print(paste("Arguments ",args))
.Ve
.IP "GNUplot:" 9
.IX Item "GNUplot:"
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang\-wrap ARG={} /usr/bin/gnuplot
\&  
\&  print "Arguments ", system(\*(Aqecho $ARG\*(Aq)
.Ve
.IP "Ruby:" 9
.IX Item "Ruby:"
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang\-wrap /usr/bin/ruby
\&  
\&  print "Arguments "
\&  puts ARGV
.Ve
.IP "Octave:" 9
.IX Item "Octave:"
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang\-wrap /usr/bin/octave
\&  
\&  printf ("Arguments");
\&  arg_list = argv ();
\&  for i = 1:nargin
\&    printf (" %s", arg_list{i});
\&  endfor
\&  printf ("\en");
.Ve
.IP "Common \s-1LISP:\s0" 9
.IX Item "Common LISP:"
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang\-wrap /usr/bin/clisp
\&  
\&  (format t "~&~S~&" \*(AqArguments)
\&  (format t "~&~S~&" *args*)
.Ve
.IP "\s-1PHP:\s0" 9
.IX Item "PHP:"
.Vb 9
\&  #!/usr/bin/parallel \-\-shebang\-wrap /usr/bin/php
\&  <?php
\&  echo "Arguments";
\&  foreach(array_slice($argv,1) as $v)
\&  {
\&    echo " $v";
\&  }
\&  echo "\en";
\&  ?>
.Ve
.IP "Node.js:" 9
.IX Item "Node.js:"
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang\-wrap /usr/bin/node
\&
\&  var myArgs = process.argv.slice(2);
\&  console.log(\*(AqArguments \*(Aq, myArgs);
.Ve
.IP "\s-1LUA:\s0" 9
.IX Item "LUA:"
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang\-wrap /usr/bin/lua
\&  
\&  io.write "Arguments"
\&  for a = 1, #arg do
\&    io.write(" ")
\&    io.write(arg[a])
\&  end
\&  print("")
.Ve
.IP "C#:" 9
.IX Item "C#:"
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang\-wrap ARGV={} /usr/bin/csharp
\&  
\&  var argv = Environment.GetEnvironmentVariable("ARGV");
\&  print("Arguments "+argv);
.Ve
.SH "Semaphore"
.IX Header "Semaphore"
\&\s-1GNU\s0 \fBparallel\fR can work as a counting semaphore. This is slower and less
efficient than its normal mode.
.PP
A counting semaphore is like a row of toilets. People needing a toilet
can use any toilet, but if there are more people than toilets, they
will have to wait for one of the toilets to become available.
.PP
An alias for \fBparallel \-\-semaphore\fR is \fBsem\fR.
.PP
\&\fBsem\fR will follow a person to the toilets, wait until a toilet is
available, leave the person in the toilet and exit.
.PP
\&\fBsem \-\-fg\fR will follow a person to the toilets, wait until a toilet is
available, stay with the person in the toilet and exit when the person
exits.
.PP
\&\fBsem \-\-wait\fR will wait for all persons to leave the toilets.
.PP
\&\fBsem\fR does not have a queue discipline, so the next person is chosen
randomly.
.PP
\&\fB\-j\fR sets the number of toilets.
.SS "Mutex"
.IX Subsection "Mutex"
The default is to have only one toilet (this is called a mutex). The
program is started in the background and \fBsem\fR exits immediately. Use
\&\fB\-\-wait\fR to wait for all \fBsem\fRs to finish:
.PP
.Vb 5
\&  sem \*(Aqsleep 1; echo The first finished\*(Aq &&
\&    echo The first is now running in the background &&
\&    sem \*(Aqsleep 1; echo The second finished\*(Aq &&
\&    echo The second is now running in the background
\&  sem \-\-wait
.Ve
.PP
Output:
.PP
.Vb 4
\&  The first is now running in the background
\&  The first finished
\&  The second is now running in the background
\&  The second finished
.Ve
.PP
The command can be run in the foreground with \fB\-\-fg\fR, which will only
exit when the command completes:
.PP
.Vb 5
\&  sem \-\-fg \*(Aqsleep 1; echo The first finished\*(Aq &&
\&    echo The first finished running in the foreground &&
\&    sem \-\-fg \*(Aqsleep 1; echo The second finished\*(Aq &&
\&    echo The second finished running in the foreground
\&  sem \-\-wait
.Ve
.PP
The difference between this and just running the command, is that a
mutex is set, so if other \fBsem\fRs were running in the background only one
would run at a time.
.PP
To control which semaphore is used, use
\&\fB\-\-semaphorename\fR/\fB\-\-id\fR. Run this in one terminal:
.PP
.Vb 1
\&  sem \-\-id my_id \-u \*(Aqecho First started; sleep 10; echo First done\*(Aq
.Ve
.PP
and simultaneously this in another terminal:
.PP
.Vb 1
\&  sem \-\-id my_id \-u \*(Aqecho Second started; sleep 10; echo Second done\*(Aq
.Ve
.PP
Note how the second will only be started when the first has finished.
.SS "Counting semaphore"
.IX Subsection "Counting semaphore"
A mutex is like having a single toilet: When it is in use everyone
else will have to wait. A counting semaphore is like having multiple
toilets: Several people can use the toilets, but when they all are in
use, everyone else will have to wait.
.PP
\&\fBsem\fR can emulate a counting semaphore. Use \fB\-\-jobs\fR to set the
number of toilets like this:
.PP
.Vb 5
\&  sem \-\-jobs 3 \-\-id my_id \-u \*(Aqecho Start 1; sleep 5; echo 1 done\*(Aq &&
\&  sem \-\-jobs 3 \-\-id my_id \-u \*(Aqecho Start 2; sleep 6; echo 2 done\*(Aq &&
\&  sem \-\-jobs 3 \-\-id my_id \-u \*(Aqecho Start 3; sleep 7; echo 3 done\*(Aq &&
\&  sem \-\-jobs 3 \-\-id my_id \-u \*(Aqecho Start 4; sleep 8; echo 4 done\*(Aq &&
\&  sem \-\-wait \-\-id my_id
.Ve
.PP
Output:
.PP
.Vb 8
\&  Start 1
\&  Start 2
\&  Start 3
\&  1 done
\&  Start 4
\&  2 done
\&  3 done
\&  4 done
.Ve
.SS "Timeout"
.IX Subsection "Timeout"
With \fB\-\-semaphoretimeout\fR you can force running the command anyway after
a period (positive number) or give up (negative number):
.PP
.Vb 4
\&  sem \-\-id foo \-u \*(Aqecho Slow started; sleep 5; echo Slow ended\*(Aq &&
\&  sem \-\-id foo \-\-semaphoretimeout 1 \*(Aqecho Forced running after 1 sec\*(Aq &&
\&  sem \-\-id foo \-\-semaphoretimeout \-2 \*(Aqecho Give up after 2 secs\*(Aq
\&  sem \-\-id foo \-\-wait
.Ve
.PP
Output:
.PP
.Vb 5
\&  Slow started
\&  parallel: Warning: Semaphore timed out. Stealing the semaphore.
\&  Forced running after 1 sec
\&  parallel: Warning: Semaphore timed out. Exiting.
\&  Slow ended
.Ve
.PP
Note how the 'Give up' was not run.
.SH "Informational"
.IX Header "Informational"
\&\s-1GNU\s0 \fBparallel\fR has some options to give short information about the
configuration.
.PP
\&\fB\-\-help\fR will print a summary of the most important options:
.PP
.Vb 1
\&  parallel \-\-help
.Ve
.PP
Output:
.PP
.Vb 1
\&  Usage:
\&  
\&  parallel [options] [command [arguments]] < list_of_arguments
\&  parallel [options] [command [arguments]] (::: arguments|:::: argfile(s))...
\&  cat ... | parallel \-\-pipe [options] [command [arguments]]
\&  
\&  \-j n            Run n jobs in parallel
\&  \-k              Keep same order
\&  \-X              Multiple arguments with context replace
\&  \-\-colsep regexp Split input on regexp for positional replacements
\&  {} {.} {/} {/.} {#} {%} {= perl code =} Replacement strings
\&  {3} {3.} {3/} {3/.} {=3 perl code =}    Positional replacement strings
\&  With \-\-plus:    {} = {+/}/{/} = {.}.{+.} = {+/}/{/.}.{+.} = {..}.{+..} =
\&                  {+/}/{/..}.{+..} = {...}.{+...} = {+/}/{/...}.{+...}
\&  
\&  \-S sshlogin     Example: foo@server.example.com
\&  \-\-slf ..        Use ~/.parallel/sshloginfile as the list of sshlogins
\&  \-\-trc {}.bar    Shorthand for \-\-transfer \-\-return {}.bar \-\-cleanup
\&  \-\-onall         Run the given command with argument on all sshlogins
\&  \-\-nonall        Run the given command with no arguments on all sshlogins
\&  
\&  \-\-pipe          Split stdin (standard input) to multiple jobs.
\&  \-\-recend str    Record end separator for \-\-pipe.
\&  \-\-recstart str  Record start separator for \-\-pipe.
\&  
\&  See \*(Aqman parallel\*(Aq for details
\&  
\&  Academic tradition requires you to cite works you base your article on.
\&  When using programs that use GNU Parallel to process data for publication
\&  please cite:
\&  
\&    O. Tange (2011): GNU Parallel \- The Command\-Line Power Tool,
\&    ;login: The USENIX Magazine, February 2011:42\-47.
\&  
\&  This helps funding further development; AND IT WON\*(AqT COST YOU A CENT.
\&  If you pay 10000 EUR you should feel free to use GNU Parallel without citing.
.Ve
.PP
When asking for help, always report the full output of this:
.PP
.Vb 1
\&  parallel \-\-version
.Ve
.PP
Output:
.PP
.Vb 6
\&  GNU parallel 20200122
\&  Copyright (C) 2007\-2020 Ole Tange, http://ole.tange.dk and Free Software
\&  Foundation, Inc.
\&  License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
\&  This is free software: you are free to change and redistribute it.
\&  GNU parallel comes with no warranty.
\&  
\&  Web site: http://www.gnu.org/software/parallel
\&  
\&  When using programs that use GNU Parallel to process data for publication
\&  please cite as described in \*(Aqparallel \-\-citation\*(Aq.
.Ve
.PP
In scripts \fB\-\-minversion\fR can be used to ensure the user has at least
this version:
.PP
.Vb 2
\&  parallel \-\-minversion 20130722 && \e
\&    echo Your version is at least 20130722.
.Ve
.PP
Output:
.PP
.Vb 2
\&  20160322
\&  Your version is at least 20130722.
.Ve
.PP
If you are using \s-1GNU\s0 \fBparallel\fR for research the BibTeX citation can be
generated using \fB\-\-citation\fR:
.PP
.Vb 1
\&  parallel \-\-citation
.Ve
.PP
Output:
.PP
.Vb 3
\&  Academic tradition requires you to cite works you base your article on.
\&  When using programs that use GNU Parallel to process data for publication
\&  please cite:
\&  
\&  @article{Tange2011a,
\&    title = {GNU Parallel \- The Command\-Line Power Tool},
\&    author = {O. Tange},
\&    address = {Frederiksberg, Denmark},
\&    journal = {;login: The USENIX Magazine},
\&    month = {Feb},
\&    number = {1},
\&    volume = {36},
\&    url = {http://www.gnu.org/s/parallel},
\&    year = {2011},
\&    pages = {42\-47},
\&    doi = {10.5281/zenodo.16303}
\&  }
\&  
\&  (Feel free to use \enocite{Tange2011a})
\&  
\&  This helps funding further development; AND IT WON\*(AqT COST YOU A CENT.
\&  If you pay 10000 EUR you should feel free to use GNU Parallel without citing.
\&  
\&  If you send a copy of your published article to tange@gnu.org, it will be
\&  mentioned in the release notes of next version of GNU Parallel.
.Ve
.PP
With \fB\-\-max\-line\-length\-allowed\fR \s-1GNU\s0 \fBparallel\fR will report the maximal
size of the command line:
.PP
.Vb 1
\&  parallel \-\-max\-line\-length\-allowed
.Ve
.PP
Output (may vary on different systems):
.PP
.Vb 1
\&  131071
.Ve
.PP
\&\fB\-\-number\-of\-cpus\fR and \fB\-\-number\-of\-cores\fR run system specific code to
determine the number of CPUs and \s-1CPU\s0 cores on the system. On
unsupported platforms they will return 1:
.PP
.Vb 2
\&  parallel \-\-number\-of\-cpus
\&  parallel \-\-number\-of\-cores
.Ve
.PP
Output (may vary on different systems):
.PP
.Vb 2
\&  4
\&  64
.Ve
.SH "Profiles"
.IX Header "Profiles"
The defaults for \s-1GNU\s0 \fBparallel\fR can be changed systemwide by putting the
command line options in \fB/etc/parallel/config\fR. They can be changed for
a user by putting them in \fB~/.parallel/config\fR.
.PP
Profiles work the same way, but have to be referred to with \fB\-\-profile\fR:
.PP
.Vb 3
\&  echo \*(Aq\-\-nice 17\*(Aq > ~/.parallel/nicetimeout
\&  echo \*(Aq\-\-timeout 300%\*(Aq >> ~/.parallel/nicetimeout
\&  parallel \-\-profile nicetimeout echo ::: A B C
.Ve
.PP
Output:
.PP
.Vb 3
\&  A
\&  B
\&  C
.Ve
.PP
Profiles can be combined:
.PP
.Vb 2
\&  echo \*(Aq\-vv \-\-dry\-run\*(Aq > ~/.parallel/dryverbose
\&  parallel \-\-profile dryverbose \-\-profile nicetimeout echo ::: A B C
.Ve
.PP
Output:
.PP
.Vb 3
\&  echo A
\&  echo B
\&  echo C
.Ve
.SH "Spread the word"
.IX Header "Spread the word"
I hope you have learned something from this tutorial.
.PP
If you like \s-1GNU\s0 \fBparallel\fR:
.IP "\(bu" 2
(Re\-)walk through the tutorial if you have not done so in the past year
(http://www.gnu.org/software/parallel/parallel_tutorial.html)
.IP "\(bu" 2
Give a demo at your local user group/your team/your colleagues
.IP "\(bu" 2
Post the intro videos and the tutorial on Reddit, Mastodon, Diaspora*,
forums, blogs, Identi.ca, Google+, Twitter, Facebook, Linkedin, and
mailing lists
.IP "\(bu" 2
Request or write a review for your favourite blog or magazine
(especially if you do something cool with \s-1GNU\s0 \fBparallel\fR)
.IP "\(bu" 2
Invite me for your next conference
.PP
If you use \s-1GNU\s0 \fBparallel\fR for research:
.IP "\(bu" 2
Please cite \s-1GNU\s0 \fBparallel\fR in you publications (use \fB\-\-citation\fR)
.PP
If \s-1GNU\s0 \fBparallel\fR saves you money:
.IP "\(bu" 2
(Have your company) donate to \s-1FSF\s0 or become a member
https://my.fsf.org/donate/
.PP
(C) 2013\-2020 Ole Tange, FDLv1.3 (See fdl.txt)
